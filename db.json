{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1536842484940},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1536842484940},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1536842484940},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1536842484940},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1536842484940},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1536842484940},{"_id":"source/_posts/MYSQL数据库笔记-1.md","hash":"b4b6cf6274430cec6c4c2f6e9595749dc0b14562","modified":1536842484936},{"_id":"source/_posts/MYSQL数据库笔记-2之分组函数及查询函数.md","hash":"20154a869dd923f842f2298f2a681a312471b69a","modified":1536842484936},{"_id":"source/_posts/MYSQL数据库笔记-3之日期处理.md","hash":"0790fb38bc6a5c397f978152ae2b72a46249f8a8","modified":1536842484940},{"_id":"source/_posts/MYSQL数据库笔记-4之连接查询.md","hash":"76827b0dff0b5c467232c531de2aa65b7f6aa49d","modified":1536842484940},{"_id":"source/_posts/MYSQL数据库笔记-5之子查询.md","hash":"bc3db0cfb3dcbd9d22dee495767e5bce4ef1a8c2","modified":1536842484940},{"_id":"source/_posts/MYSQL数据库笔记-6之limit.md","hash":"8f88227d81a1a8a9c8503896477118bae64cdc09","modified":1536842484940},{"_id":"source/_posts/MYSQL数据库笔记-7之表的创建.md","hash":"aff82f2d07654eb75b94b141bd3c2f2516974fd3","modified":1536842484940},{"_id":"source/_posts/MYSQL数据库笔记-8之约束.md","hash":"079a61ecbb144ade0f9f864a1ce607f6699a2778","modified":1536842484940},{"_id":"source/_posts/deepin下搭建基于github和hexo的个人博客.md","hash":"5a029a2c3463de9553bca36566ecda206deccacf","modified":1536850071983},{"_id":"source/_posts/git从远程库同步到本地仓库.md","hash":"d5fe0980b529f351293805acc405c8c19eabc601","modified":1536849491624},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1536842484940},{"_id":"source/_posts/使用hexo，如果换了电脑怎么更新博客.md","hash":"b506ed63bca7178959d41110c320ba208719dc3e","modified":1536854070387},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1536842484940},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1536842484940},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1536842484940},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1536842484940},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1536842484940},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1536842484940},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1536842484940},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1536842484940},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1536842484940},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1536842484940},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1536842484940},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1536842484940},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1536842484940},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1536842484940},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1536842484940},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1536842484940},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1536842484940},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1536842484940},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1536842484940},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1536842484940},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1536842484940},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1536842484940},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1536842484940},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1536842484940},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1536842484940},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1536842484940},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1536842484940},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1536842484944},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1536842484944},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1536842484940},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1536842484940},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1536842484940},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1536842484940},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1536842484940},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1536842484940},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1536842484940},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1536842484940},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1536842484940},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1536842484940},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1536842484940},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1536842484940},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1536842484940},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1536842484940},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1536842484940},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1536842484940},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1536842484944},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1536842484944},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1536842484944},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1536842484940},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1536842484944}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"MYSQL数据库笔记(1)","date":"2018-08-09T06:29:40.000Z","_content":"\nmysql -uroot -p密码   登入数据库\n\nuse 数据库名\n\n1.显示所有数据库：show databases;  \n2.显示数据库下的表：show tables;\n3.创建数据库：create database 库名 [charset utf-8]；\n4.删除数据库：drop database 库名；\n<!--more-->\n5.修改数据库名：表可以修改名，数据库不能修改名。\n6、建表： create table stu(\n          id int,\n          sname,varchar(32\n          );\n7、删除表：drop table 表名；\n8、修改表名：rename table stu to newstu;\n9、表中插入数据：(最好用这种）\ninsert into newstu(id,sname) values(1,'张三');\ninsert into newstu(id,sname) values(2,'李四');\ninsert into newstu(id,sname) values(3,'王五');\n或者\ninsert into newstu values(4,'赵六'),(5,'七');\n10、清空表中数据：truncate 表名；\n\n11、truncate和delete的区别：\ntruncate相当于删表再重建一张同样结构的表，操作后得到一张全新表。\n而delete是从删除所有的层面来操作的，把数据删除\n\n12、windows系统中若出现乱码：set names gbk(编码方式）\n\ntee /home/zhb/mysql/a.sql(选择文件路径) ：用来记录用户操作记录的\n#输入文字...\n\n13.建表语句：\ncreate table class(\nid int primary key auto_increment(表示自增),\nsname varchar(10) not null default '',\ngender char(1) not null default '',\ncompany varchar(20) not null default '',\nsalary decimal(6,2) not null default 0.00,\nfanbu smallint not null default 0\n);\n\n===添加内容：\ninsert into class(id,sname,gender,company,salary,fanbu)values(1,'张三','男','百度',8888,234);\n\n若没声明需要添加的字段，则默认添加所有。\ninsert into class\nvalues(5,'五妹','女','新浪',9999,10);\n\n部分声明字段\ninsert into class(sname,company,salary)\nvalues\n('刘备','皇室成员',14.28),\n('孙策','江东集团',55.55),\n('曹操','宦官后裔',33.88);\n\n\n===修改表内容：\nupdate class set gender='男',fanbu=99 where id=2;\nupdate class set gender='男',fanbu=23 where id=3;\nupdate class set gender='男',fanbu=43 where id=4;\n\n#改性别为男，且工资大于8000的用户的fanbu\nupdate class set fanbu=200 where salary>8000 and gender='男';\n\n===删除表的内容：只能删除行，不能删除单个列的内容。\n# 把工资大于8000的男的用户删除：\ndelete from class where salary>8000 and gender='男';\n\n===添加列：\nalter table class add score tinyint unsigned not null default 0;\n\n ====================================================\n \n\n\n14.三大类型\n\t数值型\n\t\t14.1整型:\n\t\t\t*tinyint \n\t\t\t\t空间：1字节；范围：-128～127,0～255 (2^8-1)\n\t\t\t*smallint\n\t\t\t\t空间：2字节；范围：-2^14~2^14-1,0~2^16-1\n\t\t\tmediumint\n\t\t\t\t空间：3字节；\n\t\t\t*int\n\t\t\t\t空间：4字节；\n\t\t\tbigint\n\t\t\t\t空间：8字节；\n\t\t注：\n\t\t\t不加特殊说明，默认是有符号，范围是-2^(n-1)-2^(n-1)-1,\n\t\t\tunsigned表示无符号，可以影响存储范围0-2^n-1\n\t\t\tzerofill：zero代表零，fill代表填充，表示0填充(默认unsigned类型);\n\t\t\t(M) M表示参数，要和zerofill结合才有意义：即不够位数，用0填充。\n\t\t\t\t例：添加一个学号，学号不能为负，学号位数相同。\n\t\t\t\talter table class add snum smallint(5) zerofill not null default 0;\n\t\t\t\tinsert into class(sname,snum) values('赵云',12);\n\t\t\t\tinsert into class(sname,snum) values('典韦',14);\n\n\t\t14.2小数(浮点型/定点型)\n\t\t\tfloat(M,D)：浮点\n\n\t\t\tdecimal(M,D)：定点,是把整数部分和小数部分，分开存储的，比float精确。\n\t\t\t\n\t\t\tM叫精度--->代表总位数，D叫标度--->代表小数位数 \n\n\t\t\t=======================================\n\t\t\tcreate table salary(\n\t\t\tsname varchar(20) not null default '',\n\t\t\tsal float(6,2) \n\t\t\t);\n\n\t\t\tinsert into salary values('张三',-9999.20);\n\t\t\tinsert into salary values('李四',9999.99);\n\n\t\t\talter table salary add bonus float(5,2) unsigned not null default 0.00; \n\n\t\t\tinsert into salary(sname,bonus) values('赵四',552);\n\n\t14.3 字符串类型\n\t\t*char:定长字符串  对于char(N),如果不够N个长度，则在末尾用空格补充，浪费空间。\n\t\t\n\t\t*varchar：变长字符串  varchar(n),存储0-n个字符，会有1-2个字节来标志该列的内容。\n\t\t\n\t\ttext:文本类型，可以存较大的文本段(文章，新闻)，搜索速度稍慢，不用加默认值。\n\t\t\n\t\tblob：二进制类型，用来存储图，音频像等信息\n\t\t\t意义：二进制0～255,都有可能出现，防止因为字符集的问题，导致信息丢失。\n\t\t\t如：一张图片中有0XFF个字节，这个在ASCII字符集被认为非法，在入库时被过滤了\n\n\t\tchar和varchar区别：\n\t\t=========================================\n\t\tcreate table test(\n\t\tca char(6) not null default '',\n\t\tvca varchar(6) not null default ''\n\t\t);\n\n\t\tinsert into test values('hello','hello');\n\t\tinsert into test values('aa ','aa ');\n\n\t\tconcat连接字符串用的 \n\n\t\t查看区别：\n\t\tmysql>select concat(ca,'!'),concat(vca,'!') from test;\n\t\t+----------------+-----------------+\n\t\t| concat(ca,'!') | concat(vca,'!') |\n\t\t+----------------+-----------------+\n\t\t| hello!         | hello!          |\n\t\t| aa!            | aa !            |\n\t\t+----------------+-----------------+\n\t\tchar型，如果不够n个字符，内部用空格补齐，取出时再把右侧空格删掉。\n\t\t\n\t\t速度上：定长速度快些\n\t\tchar(n)和varchar(n)限制的是字符，不是字节\n\t\tchar(2)能存2个字符，如‘福建’，'ab'\n\n\t14.4日期/时间类型\n\t\tdate 日期类型 3个字节\n\t\ttime 时间类型 3个字节\n\t\tdatetime 8个字节\n\t\tyear 1字节\n\t\ttimestamp 显示当前时间\n\t\t\n\t\tcreate table star(\n\t    sname varchar(32) not null default '',\n\t    brith date\n\t    );\n\n\n\n\n\n15、建表过程\n\t\t-就是声明字段的过程\n\t\t-建立合理的类型，充分利用存储空间\n\t\t===============================\n\t\tID(pk)   用户名   性别    体重   生日    工资    上次登入时间   个人简介\n\t\t================================================================\n\n\t\t让所有列都定长，可以极大提高查询速度\ncreate table member(\nid int(10) unsigned primary key auto_increment,\nusername char(20) not null default '',\ngender char(1) not null default '',\nweight float(4,1) unsigned not null default 0,\nbirth date not null,\nsalary float(8,2) not null default 0,\nlogin int unsigned not null default 0(时间戳)或者可以timestamp\n);\n\t\tusername char(20)会造成空间的浪费，但是提高速度。\n\t\tintro char(1500)浪费太多空间，另一方面，人的简介修改频率不高，可以把它单独列出来放另一张表\n\n\t\tcreate table member(\n\t\tid int(10) unsigned primary key not null,\n\t\tusername char(20),\n\t\tintro varchar(1500)\n\t\t);\n\n\t\t在开发中，会员的信息优化往往是把频繁用到的信息，优先考虑效率，存放到一张表中。\n\t\t不常用的信息和比较占据空间的信息，优先考虑空间战胜，存储到辅表中\n\n\n16、修改表的语法\n\t增加列：\n\t\t*在表的最后面添加:\n\t\talter table 表名 add 列名称 列类型 列参数;\n\t\t例：alter table member add username char(20) not null default '';\n\t\t\n\t\t*把新列指定加在某列后面:\n\t\talter table 表名 add 列名称 列类型 列参数 after 某列名;\n\t\t例：alter table member add gender char(1) not null default '' after birth;\n\n\t\t*把列添加在最前面：\n\t\talter table 表名 add 列名称 列类型 列参数 first;\n\t\t例：alter table member add id int(10) unsigned first;\n\n\t删除列：\n\t\talter table 表名 drop 列名;\n\t\t例：alter table member drop id;\n\n\t修改列类型：\n\t\talter table 表名 modify 列名 新的类型名 新列参数;\n\t\talter table  member modify id  int(4) not null default '';\n\n\t修改列名及列类型：\n\t\talter table 表名 change 旧列名 新列名 新类型 新参数;\n\t\talter table member change id uid int(10) unsigned;\n\n17、\n","source":"_posts/MYSQL数据库笔记-1.md","raw":"---\ntitle: MYSQL数据库笔记(1)\ndate: 2018-08-09 14:29:40\ntags:\n---\n\nmysql -uroot -p密码   登入数据库\n\nuse 数据库名\n\n1.显示所有数据库：show databases;  \n2.显示数据库下的表：show tables;\n3.创建数据库：create database 库名 [charset utf-8]；\n4.删除数据库：drop database 库名；\n<!--more-->\n5.修改数据库名：表可以修改名，数据库不能修改名。\n6、建表： create table stu(\n          id int,\n          sname,varchar(32\n          );\n7、删除表：drop table 表名；\n8、修改表名：rename table stu to newstu;\n9、表中插入数据：(最好用这种）\ninsert into newstu(id,sname) values(1,'张三');\ninsert into newstu(id,sname) values(2,'李四');\ninsert into newstu(id,sname) values(3,'王五');\n或者\ninsert into newstu values(4,'赵六'),(5,'七');\n10、清空表中数据：truncate 表名；\n\n11、truncate和delete的区别：\ntruncate相当于删表再重建一张同样结构的表，操作后得到一张全新表。\n而delete是从删除所有的层面来操作的，把数据删除\n\n12、windows系统中若出现乱码：set names gbk(编码方式）\n\ntee /home/zhb/mysql/a.sql(选择文件路径) ：用来记录用户操作记录的\n#输入文字...\n\n13.建表语句：\ncreate table class(\nid int primary key auto_increment(表示自增),\nsname varchar(10) not null default '',\ngender char(1) not null default '',\ncompany varchar(20) not null default '',\nsalary decimal(6,2) not null default 0.00,\nfanbu smallint not null default 0\n);\n\n===添加内容：\ninsert into class(id,sname,gender,company,salary,fanbu)values(1,'张三','男','百度',8888,234);\n\n若没声明需要添加的字段，则默认添加所有。\ninsert into class\nvalues(5,'五妹','女','新浪',9999,10);\n\n部分声明字段\ninsert into class(sname,company,salary)\nvalues\n('刘备','皇室成员',14.28),\n('孙策','江东集团',55.55),\n('曹操','宦官后裔',33.88);\n\n\n===修改表内容：\nupdate class set gender='男',fanbu=99 where id=2;\nupdate class set gender='男',fanbu=23 where id=3;\nupdate class set gender='男',fanbu=43 where id=4;\n\n#改性别为男，且工资大于8000的用户的fanbu\nupdate class set fanbu=200 where salary>8000 and gender='男';\n\n===删除表的内容：只能删除行，不能删除单个列的内容。\n# 把工资大于8000的男的用户删除：\ndelete from class where salary>8000 and gender='男';\n\n===添加列：\nalter table class add score tinyint unsigned not null default 0;\n\n ====================================================\n \n\n\n14.三大类型\n\t数值型\n\t\t14.1整型:\n\t\t\t*tinyint \n\t\t\t\t空间：1字节；范围：-128～127,0～255 (2^8-1)\n\t\t\t*smallint\n\t\t\t\t空间：2字节；范围：-2^14~2^14-1,0~2^16-1\n\t\t\tmediumint\n\t\t\t\t空间：3字节；\n\t\t\t*int\n\t\t\t\t空间：4字节；\n\t\t\tbigint\n\t\t\t\t空间：8字节；\n\t\t注：\n\t\t\t不加特殊说明，默认是有符号，范围是-2^(n-1)-2^(n-1)-1,\n\t\t\tunsigned表示无符号，可以影响存储范围0-2^n-1\n\t\t\tzerofill：zero代表零，fill代表填充，表示0填充(默认unsigned类型);\n\t\t\t(M) M表示参数，要和zerofill结合才有意义：即不够位数，用0填充。\n\t\t\t\t例：添加一个学号，学号不能为负，学号位数相同。\n\t\t\t\talter table class add snum smallint(5) zerofill not null default 0;\n\t\t\t\tinsert into class(sname,snum) values('赵云',12);\n\t\t\t\tinsert into class(sname,snum) values('典韦',14);\n\n\t\t14.2小数(浮点型/定点型)\n\t\t\tfloat(M,D)：浮点\n\n\t\t\tdecimal(M,D)：定点,是把整数部分和小数部分，分开存储的，比float精确。\n\t\t\t\n\t\t\tM叫精度--->代表总位数，D叫标度--->代表小数位数 \n\n\t\t\t=======================================\n\t\t\tcreate table salary(\n\t\t\tsname varchar(20) not null default '',\n\t\t\tsal float(6,2) \n\t\t\t);\n\n\t\t\tinsert into salary values('张三',-9999.20);\n\t\t\tinsert into salary values('李四',9999.99);\n\n\t\t\talter table salary add bonus float(5,2) unsigned not null default 0.00; \n\n\t\t\tinsert into salary(sname,bonus) values('赵四',552);\n\n\t14.3 字符串类型\n\t\t*char:定长字符串  对于char(N),如果不够N个长度，则在末尾用空格补充，浪费空间。\n\t\t\n\t\t*varchar：变长字符串  varchar(n),存储0-n个字符，会有1-2个字节来标志该列的内容。\n\t\t\n\t\ttext:文本类型，可以存较大的文本段(文章，新闻)，搜索速度稍慢，不用加默认值。\n\t\t\n\t\tblob：二进制类型，用来存储图，音频像等信息\n\t\t\t意义：二进制0～255,都有可能出现，防止因为字符集的问题，导致信息丢失。\n\t\t\t如：一张图片中有0XFF个字节，这个在ASCII字符集被认为非法，在入库时被过滤了\n\n\t\tchar和varchar区别：\n\t\t=========================================\n\t\tcreate table test(\n\t\tca char(6) not null default '',\n\t\tvca varchar(6) not null default ''\n\t\t);\n\n\t\tinsert into test values('hello','hello');\n\t\tinsert into test values('aa ','aa ');\n\n\t\tconcat连接字符串用的 \n\n\t\t查看区别：\n\t\tmysql>select concat(ca,'!'),concat(vca,'!') from test;\n\t\t+----------------+-----------------+\n\t\t| concat(ca,'!') | concat(vca,'!') |\n\t\t+----------------+-----------------+\n\t\t| hello!         | hello!          |\n\t\t| aa!            | aa !            |\n\t\t+----------------+-----------------+\n\t\tchar型，如果不够n个字符，内部用空格补齐，取出时再把右侧空格删掉。\n\t\t\n\t\t速度上：定长速度快些\n\t\tchar(n)和varchar(n)限制的是字符，不是字节\n\t\tchar(2)能存2个字符，如‘福建’，'ab'\n\n\t14.4日期/时间类型\n\t\tdate 日期类型 3个字节\n\t\ttime 时间类型 3个字节\n\t\tdatetime 8个字节\n\t\tyear 1字节\n\t\ttimestamp 显示当前时间\n\t\t\n\t\tcreate table star(\n\t    sname varchar(32) not null default '',\n\t    brith date\n\t    );\n\n\n\n\n\n15、建表过程\n\t\t-就是声明字段的过程\n\t\t-建立合理的类型，充分利用存储空间\n\t\t===============================\n\t\tID(pk)   用户名   性别    体重   生日    工资    上次登入时间   个人简介\n\t\t================================================================\n\n\t\t让所有列都定长，可以极大提高查询速度\ncreate table member(\nid int(10) unsigned primary key auto_increment,\nusername char(20) not null default '',\ngender char(1) not null default '',\nweight float(4,1) unsigned not null default 0,\nbirth date not null,\nsalary float(8,2) not null default 0,\nlogin int unsigned not null default 0(时间戳)或者可以timestamp\n);\n\t\tusername char(20)会造成空间的浪费，但是提高速度。\n\t\tintro char(1500)浪费太多空间，另一方面，人的简介修改频率不高，可以把它单独列出来放另一张表\n\n\t\tcreate table member(\n\t\tid int(10) unsigned primary key not null,\n\t\tusername char(20),\n\t\tintro varchar(1500)\n\t\t);\n\n\t\t在开发中，会员的信息优化往往是把频繁用到的信息，优先考虑效率，存放到一张表中。\n\t\t不常用的信息和比较占据空间的信息，优先考虑空间战胜，存储到辅表中\n\n\n16、修改表的语法\n\t增加列：\n\t\t*在表的最后面添加:\n\t\talter table 表名 add 列名称 列类型 列参数;\n\t\t例：alter table member add username char(20) not null default '';\n\t\t\n\t\t*把新列指定加在某列后面:\n\t\talter table 表名 add 列名称 列类型 列参数 after 某列名;\n\t\t例：alter table member add gender char(1) not null default '' after birth;\n\n\t\t*把列添加在最前面：\n\t\talter table 表名 add 列名称 列类型 列参数 first;\n\t\t例：alter table member add id int(10) unsigned first;\n\n\t删除列：\n\t\talter table 表名 drop 列名;\n\t\t例：alter table member drop id;\n\n\t修改列类型：\n\t\talter table 表名 modify 列名 新的类型名 新列参数;\n\t\talter table  member modify id  int(4) not null default '';\n\n\t修改列名及列类型：\n\t\talter table 表名 change 旧列名 新列名 新类型 新参数;\n\t\talter table member change id uid int(10) unsigned;\n\n17、\n","slug":"MYSQL数据库笔记-1","published":1,"updated":"2018-09-13T12:41:24.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm0r96600000mlfiwubwjans","content":"<p>mysql -uroot -p密码   登入数据库</p>\n<p>use 数据库名</p>\n<p>1.显示所有数据库：show databases;<br>2.显示数据库下的表：show tables;<br>3.创建数据库：create database 库名 [charset utf-8]；<br>4.删除数据库：drop database 库名；<br><a id=\"more\"></a><br>5.修改数据库名：表可以修改名，数据库不能修改名。<br>6、建表： create table stu(<br>          id int,<br>          sname,varchar(32<br>          );<br>7、删除表：drop table 表名；<br>8、修改表名：rename table stu to newstu;<br>9、表中插入数据：(最好用这种）<br>insert into newstu(id,sname) values(1,’张三’);<br>insert into newstu(id,sname) values(2,’李四’);<br>insert into newstu(id,sname) values(3,’王五’);<br>或者<br>insert into newstu values(4,’赵六’),(5,’七’);<br>10、清空表中数据：truncate 表名；</p>\n<p>11、truncate和delete的区别：<br>truncate相当于删表再重建一张同样结构的表，操作后得到一张全新表。<br>而delete是从删除所有的层面来操作的，把数据删除</p>\n<p>12、windows系统中若出现乱码：set names gbk(编码方式）</p>\n<p>tee /home/zhb/mysql/a.sql(选择文件路径) ：用来记录用户操作记录的</p>\n<p>#输入文字…</p>\n<p>13.建表语句：<br>create table class(<br>id int primary key auto_increment(表示自增),<br>sname varchar(10) not null default ‘’,<br>gender char(1) not null default ‘’,<br>company varchar(20) not null default ‘’,<br>salary decimal(6,2) not null default 0.00,<br>fanbu smallint not null default 0<br>);</p>\n<p>===添加内容：<br>insert into class(id,sname,gender,company,salary,fanbu)values(1,’张三’,’男’,’百度’,8888,234);</p>\n<p>若没声明需要添加的字段，则默认添加所有。<br>insert into class<br>values(5,’五妹’,’女’,’新浪’,9999,10);</p>\n<p>部分声明字段<br>insert into class(sname,company,salary)<br>values<br>(‘刘备’,’皇室成员’,14.28),<br>(‘孙策’,’江东集团’,55.55),<br>(‘曹操’,’宦官后裔’,33.88);</p>\n<p>===修改表内容：<br>update class set gender=’男’,fanbu=99 where id=2;<br>update class set gender=’男’,fanbu=23 where id=3;<br>update class set gender=’男’,fanbu=43 where id=4;</p>\n<p>#改性别为男，且工资大于8000的用户的fanbu<br>update class set fanbu=200 where salary&gt;8000 and gender=’男’;</p>\n<p>===删除表的内容：只能删除行，不能删除单个列的内容。</p>\n<h1 id=\"把工资大于8000的男的用户删除：\"><a href=\"#把工资大于8000的男的用户删除：\" class=\"headerlink\" title=\"把工资大于8000的男的用户删除：\"></a>把工资大于8000的男的用户删除：</h1><p>delete from class where salary&gt;8000 and gender=’男’;</p>\n<p>===添加列：<br>alter table class add score tinyint unsigned not null default 0;</p>\n<p> ====================================================</p>\n<p>14.三大类型<br>    数值型<br>        14.1整型:<br>            <em>tinyint<br>                空间：1字节；范围：-128～127,0～255 (2^8-1)\n            </em>smallint<br>                空间：2字节；范围：-2^14~2^14-1,0~2^16-1<br>            mediumint<br>                空间：3字节；<br>            *int<br>                空间：4字节；<br>            bigint<br>                空间：8字节；<br>        注：<br>            不加特殊说明，默认是有符号，范围是-2^(n-1)-2^(n-1)-1,<br>            unsigned表示无符号，可以影响存储范围0-2^n-1<br>            zerofill：zero代表零，fill代表填充，表示0填充(默认unsigned类型);<br>            (M) M表示参数，要和zerofill结合才有意义：即不够位数，用0填充。<br>                例：添加一个学号，学号不能为负，学号位数相同。<br>                alter table class add snum smallint(5) zerofill not null default 0;<br>                insert into class(sname,snum) values(‘赵云’,12);<br>                insert into class(sname,snum) values(‘典韦’,14);</p>\n<pre><code>    14.2小数(浮点型/定点型)\n        float(M,D)：浮点\n\n        decimal(M,D)：定点,是把整数部分和小数部分，分开存储的，比float精确。\n\n        M叫精度---&gt;代表总位数，D叫标度---&gt;代表小数位数 \n\n        =======================================\n        create table salary(\n        sname varchar(20) not null default &apos;&apos;,\n        sal float(6,2) \n        );\n\n        insert into salary values(&apos;张三&apos;,-9999.20);\n        insert into salary values(&apos;李四&apos;,9999.99);\n\n        alter table salary add bonus float(5,2) unsigned not null default 0.00; \n\n        insert into salary(sname,bonus) values(&apos;赵四&apos;,552);\n\n14.3 字符串类型\n    *char:定长字符串  对于char(N),如果不够N个长度，则在末尾用空格补充，浪费空间。\n\n    *varchar：变长字符串  varchar(n),存储0-n个字符，会有1-2个字节来标志该列的内容。\n\n    text:文本类型，可以存较大的文本段(文章，新闻)，搜索速度稍慢，不用加默认值。\n\n    blob：二进制类型，用来存储图，音频像等信息\n        意义：二进制0～255,都有可能出现，防止因为字符集的问题，导致信息丢失。\n        如：一张图片中有0XFF个字节，这个在ASCII字符集被认为非法，在入库时被过滤了\n\n    char和varchar区别：\n    =========================================\n    create table test(\n    ca char(6) not null default &apos;&apos;,\n    vca varchar(6) not null default &apos;&apos;\n    );\n\n    insert into test values(&apos;hello&apos;,&apos;hello&apos;);\n    insert into test values(&apos;aa &apos;,&apos;aa &apos;);\n\n    concat连接字符串用的 \n\n    查看区别：\n    mysql&gt;select concat(ca,&apos;!&apos;),concat(vca,&apos;!&apos;) from test;\n    +----------------+-----------------+\n    | concat(ca,&apos;!&apos;) | concat(vca,&apos;!&apos;) |\n    +----------------+-----------------+\n    | hello!         | hello!          |\n    | aa!            | aa !            |\n    +----------------+-----------------+\n    char型，如果不够n个字符，内部用空格补齐，取出时再把右侧空格删掉。\n\n    速度上：定长速度快些\n    char(n)和varchar(n)限制的是字符，不是字节\n    char(2)能存2个字符，如‘福建’，&apos;ab&apos;\n\n14.4日期/时间类型\n    date 日期类型 3个字节\n    time 时间类型 3个字节\n    datetime 8个字节\n    year 1字节\n    timestamp 显示当前时间\n\n    create table star(\n    sname varchar(32) not null default &apos;&apos;,\n    brith date\n    );\n</code></pre><p>15、建表过程<br>        -就是声明字段的过程</p>\n<pre><code>-建立合理的类型，充分利用存储空间\n===============================\nID(pk)   用户名   性别    体重   生日    工资    上次登入时间   个人简介\n================================================================\n\n让所有列都定长，可以极大提高查询速度\n</code></pre><p>create table member(<br>id int(10) unsigned primary key auto_increment,<br>username char(20) not null default ‘’,<br>gender char(1) not null default ‘’,<br>weight float(4,1) unsigned not null default 0,<br>birth date not null,<br>salary float(8,2) not null default 0,<br>login int unsigned not null default 0(时间戳)或者可以timestamp<br>);<br>        username char(20)会造成空间的浪费，但是提高速度。<br>        intro char(1500)浪费太多空间，另一方面，人的简介修改频率不高，可以把它单独列出来放另一张表</p>\n<pre><code>create table member(\nid int(10) unsigned primary key not null,\nusername char(20),\nintro varchar(1500)\n);\n\n在开发中，会员的信息优化往往是把频繁用到的信息，优先考虑效率，存放到一张表中。\n不常用的信息和比较占据空间的信息，优先考虑空间战胜，存储到辅表中\n</code></pre><p>16、修改表的语法<br>    增加列：<br>        *在表的最后面添加:<br>        alter table 表名 add 列名称 列类型 列参数;<br>        例：alter table member add username char(20) not null default ‘’;</p>\n<pre><code>    *把新列指定加在某列后面:\n    alter table 表名 add 列名称 列类型 列参数 after 某列名;\n    例：alter table member add gender char(1) not null default &apos;&apos; after birth;\n\n    *把列添加在最前面：\n    alter table 表名 add 列名称 列类型 列参数 first;\n    例：alter table member add id int(10) unsigned first;\n\n删除列：\n    alter table 表名 drop 列名;\n    例：alter table member drop id;\n\n修改列类型：\n    alter table 表名 modify 列名 新的类型名 新列参数;\n    alter table  member modify id  int(4) not null default &apos;&apos;;\n\n修改列名及列类型：\n    alter table 表名 change 旧列名 新列名 新类型 新参数;\n    alter table member change id uid int(10) unsigned;\n</code></pre><p>17、</p>\n","site":{"data":{}},"excerpt":"<p>mysql -uroot -p密码   登入数据库</p>\n<p>use 数据库名</p>\n<p>1.显示所有数据库：show databases;<br>2.显示数据库下的表：show tables;<br>3.创建数据库：create database 库名 [charset utf-8]；<br>4.删除数据库：drop database 库名；<br>","more":"<br>5.修改数据库名：表可以修改名，数据库不能修改名。<br>6、建表： create table stu(<br>          id int,<br>          sname,varchar(32<br>          );<br>7、删除表：drop table 表名；<br>8、修改表名：rename table stu to newstu;<br>9、表中插入数据：(最好用这种）<br>insert into newstu(id,sname) values(1,’张三’);<br>insert into newstu(id,sname) values(2,’李四’);<br>insert into newstu(id,sname) values(3,’王五’);<br>或者<br>insert into newstu values(4,’赵六’),(5,’七’);<br>10、清空表中数据：truncate 表名；</p>\n<p>11、truncate和delete的区别：<br>truncate相当于删表再重建一张同样结构的表，操作后得到一张全新表。<br>而delete是从删除所有的层面来操作的，把数据删除</p>\n<p>12、windows系统中若出现乱码：set names gbk(编码方式）</p>\n<p>tee /home/zhb/mysql/a.sql(选择文件路径) ：用来记录用户操作记录的</p>\n<p>#输入文字…</p>\n<p>13.建表语句：<br>create table class(<br>id int primary key auto_increment(表示自增),<br>sname varchar(10) not null default ‘’,<br>gender char(1) not null default ‘’,<br>company varchar(20) not null default ‘’,<br>salary decimal(6,2) not null default 0.00,<br>fanbu smallint not null default 0<br>);</p>\n<p>===添加内容：<br>insert into class(id,sname,gender,company,salary,fanbu)values(1,’张三’,’男’,’百度’,8888,234);</p>\n<p>若没声明需要添加的字段，则默认添加所有。<br>insert into class<br>values(5,’五妹’,’女’,’新浪’,9999,10);</p>\n<p>部分声明字段<br>insert into class(sname,company,salary)<br>values<br>(‘刘备’,’皇室成员’,14.28),<br>(‘孙策’,’江东集团’,55.55),<br>(‘曹操’,’宦官后裔’,33.88);</p>\n<p>===修改表内容：<br>update class set gender=’男’,fanbu=99 where id=2;<br>update class set gender=’男’,fanbu=23 where id=3;<br>update class set gender=’男’,fanbu=43 where id=4;</p>\n<p>#改性别为男，且工资大于8000的用户的fanbu<br>update class set fanbu=200 where salary&gt;8000 and gender=’男’;</p>\n<p>===删除表的内容：只能删除行，不能删除单个列的内容。</p>\n<h1 id=\"把工资大于8000的男的用户删除：\"><a href=\"#把工资大于8000的男的用户删除：\" class=\"headerlink\" title=\"把工资大于8000的男的用户删除：\"></a>把工资大于8000的男的用户删除：</h1><p>delete from class where salary&gt;8000 and gender=’男’;</p>\n<p>===添加列：<br>alter table class add score tinyint unsigned not null default 0;</p>\n<p> ====================================================</p>\n<p>14.三大类型<br>    数值型<br>        14.1整型:<br>            <em>tinyint<br>                空间：1字节；范围：-128～127,0～255 (2^8-1)\n            </em>smallint<br>                空间：2字节；范围：-2^14~2^14-1,0~2^16-1<br>            mediumint<br>                空间：3字节；<br>            *int<br>                空间：4字节；<br>            bigint<br>                空间：8字节；<br>        注：<br>            不加特殊说明，默认是有符号，范围是-2^(n-1)-2^(n-1)-1,<br>            unsigned表示无符号，可以影响存储范围0-2^n-1<br>            zerofill：zero代表零，fill代表填充，表示0填充(默认unsigned类型);<br>            (M) M表示参数，要和zerofill结合才有意义：即不够位数，用0填充。<br>                例：添加一个学号，学号不能为负，学号位数相同。<br>                alter table class add snum smallint(5) zerofill not null default 0;<br>                insert into class(sname,snum) values(‘赵云’,12);<br>                insert into class(sname,snum) values(‘典韦’,14);</p>\n<pre><code>    14.2小数(浮点型/定点型)\n        float(M,D)：浮点\n\n        decimal(M,D)：定点,是把整数部分和小数部分，分开存储的，比float精确。\n\n        M叫精度---&gt;代表总位数，D叫标度---&gt;代表小数位数 \n\n        =======================================\n        create table salary(\n        sname varchar(20) not null default &apos;&apos;,\n        sal float(6,2) \n        );\n\n        insert into salary values(&apos;张三&apos;,-9999.20);\n        insert into salary values(&apos;李四&apos;,9999.99);\n\n        alter table salary add bonus float(5,2) unsigned not null default 0.00; \n\n        insert into salary(sname,bonus) values(&apos;赵四&apos;,552);\n\n14.3 字符串类型\n    *char:定长字符串  对于char(N),如果不够N个长度，则在末尾用空格补充，浪费空间。\n\n    *varchar：变长字符串  varchar(n),存储0-n个字符，会有1-2个字节来标志该列的内容。\n\n    text:文本类型，可以存较大的文本段(文章，新闻)，搜索速度稍慢，不用加默认值。\n\n    blob：二进制类型，用来存储图，音频像等信息\n        意义：二进制0～255,都有可能出现，防止因为字符集的问题，导致信息丢失。\n        如：一张图片中有0XFF个字节，这个在ASCII字符集被认为非法，在入库时被过滤了\n\n    char和varchar区别：\n    =========================================\n    create table test(\n    ca char(6) not null default &apos;&apos;,\n    vca varchar(6) not null default &apos;&apos;\n    );\n\n    insert into test values(&apos;hello&apos;,&apos;hello&apos;);\n    insert into test values(&apos;aa &apos;,&apos;aa &apos;);\n\n    concat连接字符串用的 \n\n    查看区别：\n    mysql&gt;select concat(ca,&apos;!&apos;),concat(vca,&apos;!&apos;) from test;\n    +----------------+-----------------+\n    | concat(ca,&apos;!&apos;) | concat(vca,&apos;!&apos;) |\n    +----------------+-----------------+\n    | hello!         | hello!          |\n    | aa!            | aa !            |\n    +----------------+-----------------+\n    char型，如果不够n个字符，内部用空格补齐，取出时再把右侧空格删掉。\n\n    速度上：定长速度快些\n    char(n)和varchar(n)限制的是字符，不是字节\n    char(2)能存2个字符，如‘福建’，&apos;ab&apos;\n\n14.4日期/时间类型\n    date 日期类型 3个字节\n    time 时间类型 3个字节\n    datetime 8个字节\n    year 1字节\n    timestamp 显示当前时间\n\n    create table star(\n    sname varchar(32) not null default &apos;&apos;,\n    brith date\n    );\n</code></pre><p>15、建表过程<br>        -就是声明字段的过程</p>\n<pre><code>-建立合理的类型，充分利用存储空间\n===============================\nID(pk)   用户名   性别    体重   生日    工资    上次登入时间   个人简介\n================================================================\n\n让所有列都定长，可以极大提高查询速度\n</code></pre><p>create table member(<br>id int(10) unsigned primary key auto_increment,<br>username char(20) not null default ‘’,<br>gender char(1) not null default ‘’,<br>weight float(4,1) unsigned not null default 0,<br>birth date not null,<br>salary float(8,2) not null default 0,<br>login int unsigned not null default 0(时间戳)或者可以timestamp<br>);<br>        username char(20)会造成空间的浪费，但是提高速度。<br>        intro char(1500)浪费太多空间，另一方面，人的简介修改频率不高，可以把它单独列出来放另一张表</p>\n<pre><code>create table member(\nid int(10) unsigned primary key not null,\nusername char(20),\nintro varchar(1500)\n);\n\n在开发中，会员的信息优化往往是把频繁用到的信息，优先考虑效率，存放到一张表中。\n不常用的信息和比较占据空间的信息，优先考虑空间战胜，存储到辅表中\n</code></pre><p>16、修改表的语法<br>    增加列：<br>        *在表的最后面添加:<br>        alter table 表名 add 列名称 列类型 列参数;<br>        例：alter table member add username char(20) not null default ‘’;</p>\n<pre><code>    *把新列指定加在某列后面:\n    alter table 表名 add 列名称 列类型 列参数 after 某列名;\n    例：alter table member add gender char(1) not null default &apos;&apos; after birth;\n\n    *把列添加在最前面：\n    alter table 表名 add 列名称 列类型 列参数 first;\n    例：alter table member add id int(10) unsigned first;\n\n删除列：\n    alter table 表名 drop 列名;\n    例：alter table member drop id;\n\n修改列类型：\n    alter table 表名 modify 列名 新的类型名 新列参数;\n    alter table  member modify id  int(4) not null default &apos;&apos;;\n\n修改列名及列类型：\n    alter table 表名 change 旧列名 新列名 新类型 新参数;\n    alter table member change id uid int(10) unsigned;\n</code></pre><p>17、</p>"},{"title":"MYSQL数据库笔记_2之分组函数及查询函数","date":"2018-08-10T04:47:47.000Z","_content":"\n分组函数及分组查询\n1、分组函数：\n\t分组函数/聚合函数/多行处理函数：\n\t\tsum 求和\n\t\tcount 记数\n\t\t\tcount(comm)表示这个字段里面不为空的数量\n\t\t\tcount(*) 满足条件的所有记录总数\n\t\tavg 求平均值\n\t\tmax 取最大值\n\t\tmin 取最小值\n<!--more-->\n\t\t注：分组函数自动忽略空值，不需要手动的加where排除\n\t\t分组函数不能直接使用在where关键字后面\n\n\tdistinct:将查询重复的结果去除\n\t\tselect distinct job from emp;\n\t注：distinct函数前面不能出现字段\n\n\n2、分组查询涉及到的两个句子：\n\t\t- group by\n\t\t- having\n\n3、group by\n\t- 通过哪些字段进行分组\n\n\t3.1 例：找每个工作岗位的最高薪水\n\t\t先按job分组，再求每一组的最高薪水 \n\t\tselect job,max(sal) msal from emp group by job;\n\n\n\t\tselect ename，job,max(sal) msal from emp group by job;\n\t\t这条语句是错误的，select后面不能跟ename\n\n\t\t注：若一条DQL语句当中有 group by子句，那么select关键字后面只能跟参与分组的字段和分组函数。\n\n\t3.2 例：找出每个部门的平均薪水\n\t\tmysql> select deptno,avg(sal) from emp group by deptno;\n\t\t+--------+-------------+\n\t\t| deptno | avg(sal)    |\n\t\t+--------+-------------+\n\t\t|     10 | 2916.666667 |\n\t\t|     20 | 2175.000000 |\n\t\t|     30 | 1566.666667 |\n\t\t+--------+-------------+\n\n\t3.3 例：计算不同部门不同工作岗位的最高薪水\n\t\tmysql> select deptno,job,max(sal) from emp group by job,deptno;\n\t\t+--------+-----------+----------+\n\t\t| deptno | job       | max(sal) |\n\t\t+--------+-----------+----------+\n\t\t|     20 | ANALYST   |  3000.00 |\n\t\t|     10 | CLERK     |  1300.00 |\n\t\t|     20 | CLERK     |  1100.00 |\n\t\t|     30 | CLERK     |   950.00 |\n\t\t|     10 | MANAGER   |  2450.00 |\n\t\t|     20 | MANAGER   |  2975.00 |\n\t\t|     30 | MANAGER   |  2850.00 |\n\t\t|     10 | PRESIDENT |  5000.00 |\n\t\t|     30 | SALESMAN  |  1600.00 |\n\t\t+--------+-----------+----------+\n\n\t3.4 找出每个工作岗位的最高薪水，除MANAGER之外。\n\t\tselect job,max(sal) as msal from emp where job!='manager' group by job;\n\t\tor\n\t\tselect job,max(sal) as msal from emp group by job having job!='manager' ;\n\t\t+-----------+---------+\n\t\t| job       | msal    |\n\t\t+-----------+---------+\n\t\t| ANALYST   | 3000.00 |\n\t\t| CLERK     | 1300.00 |\n\t\t| PRESIDENT | 5000.00 |\n\t\t| SALESMAN  | 1600.00 |\n\t\t+-----------+---------+\n\n\t3.5 找出每个工作岗位的平均薪水，要求显示平均薪水大于1500.\n\t\tmysql> select job,avg(sal) from emp where avg(sal) > 1500 group by job ;\n\t\t这是错误的！\n\t\twhere后面不能直接使用分组函数。\n\t\t分组函数必须在分组完成后执行，而分组需要gruop by，而gruop by在where后面执行。\n\n\n\t\t\n\n3、having\n\thaving和where都是为了完成数据过滤。\n\twhere和having后面都是添加条件。\n\twhere在group by之前完成过滤。\n\thaving在group by 之后完成过滤。\n\n\t例：找出每个工作岗位的平均薪水，要求显示平均薪水大于1500.\n\t\tmysql> select job,avg(sal) from emp group by job having avg(sal) > 1500;\n\t\t+-----------+-------------+\n\t\t| job       | avg(sal)    |\n\t\t+-----------+-------------+\n\t\t| ANALYST   | 3000.000000 |\n\t\t| MANAGER   | 2758.333333 |\n\t\t| PRESIDENT | 5000.000000 |\n\t\t+-----------+-------------+\n\n\t\t原则：尽量在where中过滤，无法过滤的数据，通常都是需要先分组之后再过滤的，这个时候可以选择使用having。效率问题\n\n4、一个完整的DQL语句总结：\n\tselect \n\t\t....\n\tfrom\n\t\t....\n\twhere\n\t\t....\n\tgroup by\n\t\t....\n\thaving\n\t\t....\n\torder by\n\t\t....\n\n\t以上关键字顺序不能变，严格遵守\n\t执行顺序：\n\t\t1.from          从某张表中检索数据\n\t\t2.where \t\t经过某条件进行过滤\n\t\t3.group by \t\t分组\n\t\t4.having \t\t分组之后不满足条件再筛选\n\t\t5.select\t\t查询出来\n\t\t6.order by \t\t排序输出\n","source":"_posts/MYSQL数据库笔记-2之分组函数及查询函数.md","raw":"---\ntitle: MYSQL数据库笔记_2之分组函数及查询函数\ndate: 2018-08-10 12:47:47\ntags:\n---\n\n分组函数及分组查询\n1、分组函数：\n\t分组函数/聚合函数/多行处理函数：\n\t\tsum 求和\n\t\tcount 记数\n\t\t\tcount(comm)表示这个字段里面不为空的数量\n\t\t\tcount(*) 满足条件的所有记录总数\n\t\tavg 求平均值\n\t\tmax 取最大值\n\t\tmin 取最小值\n<!--more-->\n\t\t注：分组函数自动忽略空值，不需要手动的加where排除\n\t\t分组函数不能直接使用在where关键字后面\n\n\tdistinct:将查询重复的结果去除\n\t\tselect distinct job from emp;\n\t注：distinct函数前面不能出现字段\n\n\n2、分组查询涉及到的两个句子：\n\t\t- group by\n\t\t- having\n\n3、group by\n\t- 通过哪些字段进行分组\n\n\t3.1 例：找每个工作岗位的最高薪水\n\t\t先按job分组，再求每一组的最高薪水 \n\t\tselect job,max(sal) msal from emp group by job;\n\n\n\t\tselect ename，job,max(sal) msal from emp group by job;\n\t\t这条语句是错误的，select后面不能跟ename\n\n\t\t注：若一条DQL语句当中有 group by子句，那么select关键字后面只能跟参与分组的字段和分组函数。\n\n\t3.2 例：找出每个部门的平均薪水\n\t\tmysql> select deptno,avg(sal) from emp group by deptno;\n\t\t+--------+-------------+\n\t\t| deptno | avg(sal)    |\n\t\t+--------+-------------+\n\t\t|     10 | 2916.666667 |\n\t\t|     20 | 2175.000000 |\n\t\t|     30 | 1566.666667 |\n\t\t+--------+-------------+\n\n\t3.3 例：计算不同部门不同工作岗位的最高薪水\n\t\tmysql> select deptno,job,max(sal) from emp group by job,deptno;\n\t\t+--------+-----------+----------+\n\t\t| deptno | job       | max(sal) |\n\t\t+--------+-----------+----------+\n\t\t|     20 | ANALYST   |  3000.00 |\n\t\t|     10 | CLERK     |  1300.00 |\n\t\t|     20 | CLERK     |  1100.00 |\n\t\t|     30 | CLERK     |   950.00 |\n\t\t|     10 | MANAGER   |  2450.00 |\n\t\t|     20 | MANAGER   |  2975.00 |\n\t\t|     30 | MANAGER   |  2850.00 |\n\t\t|     10 | PRESIDENT |  5000.00 |\n\t\t|     30 | SALESMAN  |  1600.00 |\n\t\t+--------+-----------+----------+\n\n\t3.4 找出每个工作岗位的最高薪水，除MANAGER之外。\n\t\tselect job,max(sal) as msal from emp where job!='manager' group by job;\n\t\tor\n\t\tselect job,max(sal) as msal from emp group by job having job!='manager' ;\n\t\t+-----------+---------+\n\t\t| job       | msal    |\n\t\t+-----------+---------+\n\t\t| ANALYST   | 3000.00 |\n\t\t| CLERK     | 1300.00 |\n\t\t| PRESIDENT | 5000.00 |\n\t\t| SALESMAN  | 1600.00 |\n\t\t+-----------+---------+\n\n\t3.5 找出每个工作岗位的平均薪水，要求显示平均薪水大于1500.\n\t\tmysql> select job,avg(sal) from emp where avg(sal) > 1500 group by job ;\n\t\t这是错误的！\n\t\twhere后面不能直接使用分组函数。\n\t\t分组函数必须在分组完成后执行，而分组需要gruop by，而gruop by在where后面执行。\n\n\n\t\t\n\n3、having\n\thaving和where都是为了完成数据过滤。\n\twhere和having后面都是添加条件。\n\twhere在group by之前完成过滤。\n\thaving在group by 之后完成过滤。\n\n\t例：找出每个工作岗位的平均薪水，要求显示平均薪水大于1500.\n\t\tmysql> select job,avg(sal) from emp group by job having avg(sal) > 1500;\n\t\t+-----------+-------------+\n\t\t| job       | avg(sal)    |\n\t\t+-----------+-------------+\n\t\t| ANALYST   | 3000.000000 |\n\t\t| MANAGER   | 2758.333333 |\n\t\t| PRESIDENT | 5000.000000 |\n\t\t+-----------+-------------+\n\n\t\t原则：尽量在where中过滤，无法过滤的数据，通常都是需要先分组之后再过滤的，这个时候可以选择使用having。效率问题\n\n4、一个完整的DQL语句总结：\n\tselect \n\t\t....\n\tfrom\n\t\t....\n\twhere\n\t\t....\n\tgroup by\n\t\t....\n\thaving\n\t\t....\n\torder by\n\t\t....\n\n\t以上关键字顺序不能变，严格遵守\n\t执行顺序：\n\t\t1.from          从某张表中检索数据\n\t\t2.where \t\t经过某条件进行过滤\n\t\t3.group by \t\t分组\n\t\t4.having \t\t分组之后不满足条件再筛选\n\t\t5.select\t\t查询出来\n\t\t6.order by \t\t排序输出\n","slug":"MYSQL数据库笔记-2之分组函数及查询函数","published":1,"updated":"2018-09-13T12:41:24.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm0r96680001mlfid9advv4o","content":"<p>分组函数及分组查询<br>1、分组函数：<br>    分组函数/聚合函数/多行处理函数：<br>        sum 求和<br>        count 记数<br>            count(comm)表示这个字段里面不为空的数量<br>            count(*) 满足条件的所有记录总数<br>        avg 求平均值<br>        max 取最大值<br>        min 取最小值<br><a id=\"more\"></a><br>        注：分组函数自动忽略空值，不需要手动的加where排除<br>        分组函数不能直接使用在where关键字后面</p>\n<pre><code>distinct:将查询重复的结果去除\n    select distinct job from emp;\n注：distinct函数前面不能出现字段\n</code></pre><p>2、分组查询涉及到的两个句子：</p>\n<pre><code>- group by\n- having\n</code></pre><p>3、group by</p>\n<pre><code>- 通过哪些字段进行分组\n\n3.1 例：找每个工作岗位的最高薪水\n    先按job分组，再求每一组的最高薪水 \n    select job,max(sal) msal from emp group by job;\n\n\n    select ename，job,max(sal) msal from emp group by job;\n    这条语句是错误的，select后面不能跟ename\n\n    注：若一条DQL语句当中有 group by子句，那么select关键字后面只能跟参与分组的字段和分组函数。\n\n3.2 例：找出每个部门的平均薪水\n    mysql&gt; select deptno,avg(sal) from emp group by deptno;\n    +--------+-------------+\n    | deptno | avg(sal)    |\n    +--------+-------------+\n    |     10 | 2916.666667 |\n    |     20 | 2175.000000 |\n    |     30 | 1566.666667 |\n    +--------+-------------+\n\n3.3 例：计算不同部门不同工作岗位的最高薪水\n    mysql&gt; select deptno,job,max(sal) from emp group by job,deptno;\n    +--------+-----------+----------+\n    | deptno | job       | max(sal) |\n    +--------+-----------+----------+\n    |     20 | ANALYST   |  3000.00 |\n    |     10 | CLERK     |  1300.00 |\n    |     20 | CLERK     |  1100.00 |\n    |     30 | CLERK     |   950.00 |\n    |     10 | MANAGER   |  2450.00 |\n    |     20 | MANAGER   |  2975.00 |\n    |     30 | MANAGER   |  2850.00 |\n    |     10 | PRESIDENT |  5000.00 |\n    |     30 | SALESMAN  |  1600.00 |\n    +--------+-----------+----------+\n\n3.4 找出每个工作岗位的最高薪水，除MANAGER之外。\n    select job,max(sal) as msal from emp where job!=&apos;manager&apos; group by job;\n    or\n    select job,max(sal) as msal from emp group by job having job!=&apos;manager&apos; ;\n    +-----------+---------+\n    | job       | msal    |\n    +-----------+---------+\n    | ANALYST   | 3000.00 |\n    | CLERK     | 1300.00 |\n    | PRESIDENT | 5000.00 |\n    | SALESMAN  | 1600.00 |\n    +-----------+---------+\n\n3.5 找出每个工作岗位的平均薪水，要求显示平均薪水大于1500.\n    mysql&gt; select job,avg(sal) from emp where avg(sal) &gt; 1500 group by job ;\n    这是错误的！\n    where后面不能直接使用分组函数。\n    分组函数必须在分组完成后执行，而分组需要gruop by，而gruop by在where后面执行。\n</code></pre><p>3、having<br>    having和where都是为了完成数据过滤。<br>    where和having后面都是添加条件。<br>    where在group by之前完成过滤。<br>    having在group by 之后完成过滤。</p>\n<pre><code>例：找出每个工作岗位的平均薪水，要求显示平均薪水大于1500.\n    mysql&gt; select job,avg(sal) from emp group by job having avg(sal) &gt; 1500;\n    +-----------+-------------+\n    | job       | avg(sal)    |\n    +-----------+-------------+\n    | ANALYST   | 3000.000000 |\n    | MANAGER   | 2758.333333 |\n    | PRESIDENT | 5000.000000 |\n    +-----------+-------------+\n\n    原则：尽量在where中过滤，无法过滤的数据，通常都是需要先分组之后再过滤的，这个时候可以选择使用having。效率问题\n</code></pre><p>4、一个完整的DQL语句总结：<br>    select<br>        ….<br>    from<br>        ….<br>    where<br>        ….<br>    group by<br>        ….<br>    having<br>        ….<br>    order by<br>        ….</p>\n<pre><code>以上关键字顺序不能变，严格遵守\n执行顺序：\n    1.from          从某张表中检索数据\n    2.where         经过某条件进行过滤\n    3.group by         分组\n    4.having         分组之后不满足条件再筛选\n    5.select        查询出来\n    6.order by         排序输出\n</code></pre>","site":{"data":{}},"excerpt":"<p>分组函数及分组查询<br>1、分组函数：<br>    分组函数/聚合函数/多行处理函数：<br>        sum 求和<br>        count 记数<br>            count(comm)表示这个字段里面不为空的数量<br>            count(*) 满足条件的所有记录总数<br>        avg 求平均值<br>        max 取最大值<br>        min 取最小值<br>","more":"<br>        注：分组函数自动忽略空值，不需要手动的加where排除<br>        分组函数不能直接使用在where关键字后面</p>\n<pre><code>distinct:将查询重复的结果去除\n    select distinct job from emp;\n注：distinct函数前面不能出现字段\n</code></pre><p>2、分组查询涉及到的两个句子：</p>\n<pre><code>- group by\n- having\n</code></pre><p>3、group by</p>\n<pre><code>- 通过哪些字段进行分组\n\n3.1 例：找每个工作岗位的最高薪水\n    先按job分组，再求每一组的最高薪水 \n    select job,max(sal) msal from emp group by job;\n\n\n    select ename，job,max(sal) msal from emp group by job;\n    这条语句是错误的，select后面不能跟ename\n\n    注：若一条DQL语句当中有 group by子句，那么select关键字后面只能跟参与分组的字段和分组函数。\n\n3.2 例：找出每个部门的平均薪水\n    mysql&gt; select deptno,avg(sal) from emp group by deptno;\n    +--------+-------------+\n    | deptno | avg(sal)    |\n    +--------+-------------+\n    |     10 | 2916.666667 |\n    |     20 | 2175.000000 |\n    |     30 | 1566.666667 |\n    +--------+-------------+\n\n3.3 例：计算不同部门不同工作岗位的最高薪水\n    mysql&gt; select deptno,job,max(sal) from emp group by job,deptno;\n    +--------+-----------+----------+\n    | deptno | job       | max(sal) |\n    +--------+-----------+----------+\n    |     20 | ANALYST   |  3000.00 |\n    |     10 | CLERK     |  1300.00 |\n    |     20 | CLERK     |  1100.00 |\n    |     30 | CLERK     |   950.00 |\n    |     10 | MANAGER   |  2450.00 |\n    |     20 | MANAGER   |  2975.00 |\n    |     30 | MANAGER   |  2850.00 |\n    |     10 | PRESIDENT |  5000.00 |\n    |     30 | SALESMAN  |  1600.00 |\n    +--------+-----------+----------+\n\n3.4 找出每个工作岗位的最高薪水，除MANAGER之外。\n    select job,max(sal) as msal from emp where job!=&apos;manager&apos; group by job;\n    or\n    select job,max(sal) as msal from emp group by job having job!=&apos;manager&apos; ;\n    +-----------+---------+\n    | job       | msal    |\n    +-----------+---------+\n    | ANALYST   | 3000.00 |\n    | CLERK     | 1300.00 |\n    | PRESIDENT | 5000.00 |\n    | SALESMAN  | 1600.00 |\n    +-----------+---------+\n\n3.5 找出每个工作岗位的平均薪水，要求显示平均薪水大于1500.\n    mysql&gt; select job,avg(sal) from emp where avg(sal) &gt; 1500 group by job ;\n    这是错误的！\n    where后面不能直接使用分组函数。\n    分组函数必须在分组完成后执行，而分组需要gruop by，而gruop by在where后面执行。\n</code></pre><p>3、having<br>    having和where都是为了完成数据过滤。<br>    where和having后面都是添加条件。<br>    where在group by之前完成过滤。<br>    having在group by 之后完成过滤。</p>\n<pre><code>例：找出每个工作岗位的平均薪水，要求显示平均薪水大于1500.\n    mysql&gt; select job,avg(sal) from emp group by job having avg(sal) &gt; 1500;\n    +-----------+-------------+\n    | job       | avg(sal)    |\n    +-----------+-------------+\n    | ANALYST   | 3000.000000 |\n    | MANAGER   | 2758.333333 |\n    | PRESIDENT | 5000.000000 |\n    +-----------+-------------+\n\n    原则：尽量在where中过滤，无法过滤的数据，通常都是需要先分组之后再过滤的，这个时候可以选择使用having。效率问题\n</code></pre><p>4、一个完整的DQL语句总结：<br>    select<br>        ….<br>    from<br>        ….<br>    where<br>        ….<br>    group by<br>        ….<br>    having<br>        ….<br>    order by<br>        ….</p>\n<pre><code>以上关键字顺序不能变，严格遵守\n执行顺序：\n    1.from          从某张表中检索数据\n    2.where         经过某条件进行过滤\n    3.group by         分组\n    4.having         分组之后不满足条件再筛选\n    5.select        查询出来\n    6.order by         排序输出\n</code></pre>"},{"title":"MYSQL数据库笔记_3之日期处理","date":"2018-08-10T08:16:07.000Z","_content":"\n1、关于MYSQL中的日期处理\n\t1.1 第一个数据库处理日期的时候，采用的机制是不同的，日期处理都有自己的一套机制。\n\t所以在实际开发中，表中的字段定义为DATA类型，这种情况很少。因为一旦使用日期类型，\n\t那么其他程序将不能够通用。实际开发中，一般会使用‘日期字符串‘来表示日期。\n\n2、日期处理函数：\n\t- str_to_date\n\t- date_formate\n\n3、str_to_date\n\t3.1 该函数作用：将’日期字符串‘转换成’日期类型‘数据。[varchar-->date]\n\t3.2 该函数的执行结果是DATE类型\n\t3.3 格式：\n\t\tstr_to_date('日期字符串','日期格式')\n<!--more-->\n\t3.4 MYSQL日期格式：\n\t\t%Y\t年\n\t\t%M  月\n\t\t%d  日\n\t\t%H  时\n\t\t%i  分\n\t\t%s  秒\n\n\t3.5 例：查询出1980-12-17入职的员工\n\n\t\tmysql> select ename,hiredate from emp where hiredate='1980-12-17';\n\t\t+--------+------------+\n\t\t| ename  | hiredate   |\n\t\t+--------+------------+\n\t\t| SIMITH | 1980-12-17 |\n\t\t+--------+------------+\n\t\tMYSQL默认的日期格式%Y-%m-%d,以上的日期字符串’1980-12-17‘正好和默认的日期格式一样，存在了自动类型转换，自动将日期字符串转换成了日期类型，所以以上查询可以查询出结果。\n\n\t\tmysql> select ename,hiredate from emp where hiredate='12-17-1980';\n\t\tEmpty set, 2 warnings (0.00 sec)\n\t\t'12-17-1980' 日期字符串和MYSQL默认的日期格式不同\n\t\thiredate是DATE类型，'12-17-1980'是一个字符串varchar类型，类型不匹配。所以无法查询结果，会有错误发生。\n\n\t\t纠正以上错误：\n\t\tmysql> select ename,hiredate from emp where hiredate=str_to_date('12-17-1980','%m-%d-%Y');\n\t\t+--------+------------+\n\t\t| ename  | hiredate   |\n\t\t+--------+------------+\n\t\t| SIMITH | 1980-12-17 |\n\t\t+--------+------------+\n\n\t3.6例：\n\t创建学生表：\n\tcreate table t_student(\n\t\tid int(10),\n\t\tname varchar(32),\n\t\tbirth date\n\t);\n\n\t插入数据：\n\tinsert into t_student(id,name,birth) values(1,'jack','1980-10-11');\n\t以上可以执行，因为格式和默认日期格式相同，所以自动转换类型。\n\n\tinsert into t_student(id,name,birth) values(2,'road','10-15-1982');\n\tERROR 1292 (22007): Incorrect date value: '10-15-1982' for column 'birth' at row 1\n\t以上发生错误：\n\t\t1、和默认格式不同\n\t\t2、'10-15-1982'是varchar类型，和DATE类型不同\n\n\t纠正：\n\tinsert into t_student(id,name,birth) values(2,'road',str_to_date('10-15-1982','%m-%d-%Y'));\n\n\n4、date_format\n\t4.1 作用：将日期类型DATE转换成具有特定格式的日期字符串varchar[date-->varchar]\n\n\t4.2 运算结果：varchar类型\n\n\t4.3 语法格式：\n\t\tdate_format(日期类型数据，'日期格式')\n\n\t4.4 例：查询员工的入职日期，以‘%m-%d-%Y’的格式显示到窗口中\n\tmysql> select ename,date_format(hiredate,'%m-%d-%Y') hiredate from emp;\n\t+--------+------------+\n\t| ename  | hiredate   |\n\t+--------+------------+\n\t| SIMITH | 12-17-1980 |\n\t| ALLEN  | 02-20-1981 |\n\t| WARD   | 02-22-1981 |\n\t| JONES  | 04-02-1981 |\n\t| MARTIN | 09-28-1981 |\n\t| BLAKE  | 05-01-1981 |\n\t| CLARK  | 06-09-1981 |\n\t| SCOTT  | 04-19-1987 |\n\t| KING   | 11-17-1981 |\n\t| TURNER | 09-08-1981 |\n\t| ADAMS  | 05-23-1987 |\n\t| JAMES  | 12-03-1981 |\n\t| FORD   | 12-03-1981 |\n\t| MILLER | 01-23-1982 |\n\t+--------+------------+\n\n","source":"_posts/MYSQL数据库笔记-3之日期处理.md","raw":"---\ntitle: MYSQL数据库笔记_3之日期处理\ndate: 2018-08-10 16:16:07\ntags:\n---\n\n1、关于MYSQL中的日期处理\n\t1.1 第一个数据库处理日期的时候，采用的机制是不同的，日期处理都有自己的一套机制。\n\t所以在实际开发中，表中的字段定义为DATA类型，这种情况很少。因为一旦使用日期类型，\n\t那么其他程序将不能够通用。实际开发中，一般会使用‘日期字符串‘来表示日期。\n\n2、日期处理函数：\n\t- str_to_date\n\t- date_formate\n\n3、str_to_date\n\t3.1 该函数作用：将’日期字符串‘转换成’日期类型‘数据。[varchar-->date]\n\t3.2 该函数的执行结果是DATE类型\n\t3.3 格式：\n\t\tstr_to_date('日期字符串','日期格式')\n<!--more-->\n\t3.4 MYSQL日期格式：\n\t\t%Y\t年\n\t\t%M  月\n\t\t%d  日\n\t\t%H  时\n\t\t%i  分\n\t\t%s  秒\n\n\t3.5 例：查询出1980-12-17入职的员工\n\n\t\tmysql> select ename,hiredate from emp where hiredate='1980-12-17';\n\t\t+--------+------------+\n\t\t| ename  | hiredate   |\n\t\t+--------+------------+\n\t\t| SIMITH | 1980-12-17 |\n\t\t+--------+------------+\n\t\tMYSQL默认的日期格式%Y-%m-%d,以上的日期字符串’1980-12-17‘正好和默认的日期格式一样，存在了自动类型转换，自动将日期字符串转换成了日期类型，所以以上查询可以查询出结果。\n\n\t\tmysql> select ename,hiredate from emp where hiredate='12-17-1980';\n\t\tEmpty set, 2 warnings (0.00 sec)\n\t\t'12-17-1980' 日期字符串和MYSQL默认的日期格式不同\n\t\thiredate是DATE类型，'12-17-1980'是一个字符串varchar类型，类型不匹配。所以无法查询结果，会有错误发生。\n\n\t\t纠正以上错误：\n\t\tmysql> select ename,hiredate from emp where hiredate=str_to_date('12-17-1980','%m-%d-%Y');\n\t\t+--------+------------+\n\t\t| ename  | hiredate   |\n\t\t+--------+------------+\n\t\t| SIMITH | 1980-12-17 |\n\t\t+--------+------------+\n\n\t3.6例：\n\t创建学生表：\n\tcreate table t_student(\n\t\tid int(10),\n\t\tname varchar(32),\n\t\tbirth date\n\t);\n\n\t插入数据：\n\tinsert into t_student(id,name,birth) values(1,'jack','1980-10-11');\n\t以上可以执行，因为格式和默认日期格式相同，所以自动转换类型。\n\n\tinsert into t_student(id,name,birth) values(2,'road','10-15-1982');\n\tERROR 1292 (22007): Incorrect date value: '10-15-1982' for column 'birth' at row 1\n\t以上发生错误：\n\t\t1、和默认格式不同\n\t\t2、'10-15-1982'是varchar类型，和DATE类型不同\n\n\t纠正：\n\tinsert into t_student(id,name,birth) values(2,'road',str_to_date('10-15-1982','%m-%d-%Y'));\n\n\n4、date_format\n\t4.1 作用：将日期类型DATE转换成具有特定格式的日期字符串varchar[date-->varchar]\n\n\t4.2 运算结果：varchar类型\n\n\t4.3 语法格式：\n\t\tdate_format(日期类型数据，'日期格式')\n\n\t4.4 例：查询员工的入职日期，以‘%m-%d-%Y’的格式显示到窗口中\n\tmysql> select ename,date_format(hiredate,'%m-%d-%Y') hiredate from emp;\n\t+--------+------------+\n\t| ename  | hiredate   |\n\t+--------+------------+\n\t| SIMITH | 12-17-1980 |\n\t| ALLEN  | 02-20-1981 |\n\t| WARD   | 02-22-1981 |\n\t| JONES  | 04-02-1981 |\n\t| MARTIN | 09-28-1981 |\n\t| BLAKE  | 05-01-1981 |\n\t| CLARK  | 06-09-1981 |\n\t| SCOTT  | 04-19-1987 |\n\t| KING   | 11-17-1981 |\n\t| TURNER | 09-08-1981 |\n\t| ADAMS  | 05-23-1987 |\n\t| JAMES  | 12-03-1981 |\n\t| FORD   | 12-03-1981 |\n\t| MILLER | 01-23-1982 |\n\t+--------+------------+\n\n","slug":"MYSQL数据库笔记-3之日期处理","published":1,"updated":"2018-09-13T12:41:24.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm0r966c0002mlfiaqzqu2rk","content":"<p>1、关于MYSQL中的日期处理<br>    1.1 第一个数据库处理日期的时候，采用的机制是不同的，日期处理都有自己的一套机制。<br>    所以在实际开发中，表中的字段定义为DATA类型，这种情况很少。因为一旦使用日期类型，<br>    那么其他程序将不能够通用。实际开发中，一般会使用‘日期字符串‘来表示日期。</p>\n<p>2、日期处理函数：</p>\n<pre><code>- str_to_date\n- date_formate\n</code></pre><p>3、str_to_date<br>    3.1 该函数作用：将’日期字符串‘转换成’日期类型‘数据。[varchar–&gt;date]<br>    3.2 该函数的执行结果是DATE类型<br>    3.3 格式：<br>        str_to_date(‘日期字符串’,’日期格式’)<br><a id=\"more\"></a><br>    3.4 MYSQL日期格式：<br>        %Y    年<br>        %M  月<br>        %d  日<br>        %H  时<br>        %i  分<br>        %s  秒</p>\n<pre><code>3.5 例：查询出1980-12-17入职的员工\n\n    mysql&gt; select ename,hiredate from emp where hiredate=&apos;1980-12-17&apos;;\n    +--------+------------+\n    | ename  | hiredate   |\n    +--------+------------+\n    | SIMITH | 1980-12-17 |\n    +--------+------------+\n    MYSQL默认的日期格式%Y-%m-%d,以上的日期字符串’1980-12-17‘正好和默认的日期格式一样，存在了自动类型转换，自动将日期字符串转换成了日期类型，所以以上查询可以查询出结果。\n\n    mysql&gt; select ename,hiredate from emp where hiredate=&apos;12-17-1980&apos;;\n    Empty set, 2 warnings (0.00 sec)\n    &apos;12-17-1980&apos; 日期字符串和MYSQL默认的日期格式不同\n    hiredate是DATE类型，&apos;12-17-1980&apos;是一个字符串varchar类型，类型不匹配。所以无法查询结果，会有错误发生。\n\n    纠正以上错误：\n    mysql&gt; select ename,hiredate from emp where hiredate=str_to_date(&apos;12-17-1980&apos;,&apos;%m-%d-%Y&apos;);\n    +--------+------------+\n    | ename  | hiredate   |\n    +--------+------------+\n    | SIMITH | 1980-12-17 |\n    +--------+------------+\n\n3.6例：\n创建学生表：\ncreate table t_student(\n    id int(10),\n    name varchar(32),\n    birth date\n);\n\n插入数据：\ninsert into t_student(id,name,birth) values(1,&apos;jack&apos;,&apos;1980-10-11&apos;);\n以上可以执行，因为格式和默认日期格式相同，所以自动转换类型。\n\ninsert into t_student(id,name,birth) values(2,&apos;road&apos;,&apos;10-15-1982&apos;);\nERROR 1292 (22007): Incorrect date value: &apos;10-15-1982&apos; for column &apos;birth&apos; at row 1\n以上发生错误：\n    1、和默认格式不同\n    2、&apos;10-15-1982&apos;是varchar类型，和DATE类型不同\n\n纠正：\ninsert into t_student(id,name,birth) values(2,&apos;road&apos;,str_to_date(&apos;10-15-1982&apos;,&apos;%m-%d-%Y&apos;));\n</code></pre><p>4、date_format<br>    4.1 作用：将日期类型DATE转换成具有特定格式的日期字符串varchar[date–&gt;varchar]</p>\n<pre><code>4.2 运算结果：varchar类型\n\n4.3 语法格式：\n    date_format(日期类型数据，&apos;日期格式&apos;)\n\n4.4 例：查询员工的入职日期，以‘%m-%d-%Y’的格式显示到窗口中\nmysql&gt; select ename,date_format(hiredate,&apos;%m-%d-%Y&apos;) hiredate from emp;\n+--------+------------+\n| ename  | hiredate   |\n+--------+------------+\n| SIMITH | 12-17-1980 |\n| ALLEN  | 02-20-1981 |\n| WARD   | 02-22-1981 |\n| JONES  | 04-02-1981 |\n| MARTIN | 09-28-1981 |\n| BLAKE  | 05-01-1981 |\n| CLARK  | 06-09-1981 |\n| SCOTT  | 04-19-1987 |\n| KING   | 11-17-1981 |\n| TURNER | 09-08-1981 |\n| ADAMS  | 05-23-1987 |\n| JAMES  | 12-03-1981 |\n| FORD   | 12-03-1981 |\n| MILLER | 01-23-1982 |\n+--------+------------+\n</code></pre>","site":{"data":{}},"excerpt":"<p>1、关于MYSQL中的日期处理<br>    1.1 第一个数据库处理日期的时候，采用的机制是不同的，日期处理都有自己的一套机制。<br>    所以在实际开发中，表中的字段定义为DATA类型，这种情况很少。因为一旦使用日期类型，<br>    那么其他程序将不能够通用。实际开发中，一般会使用‘日期字符串‘来表示日期。</p>\n<p>2、日期处理函数：</p>\n<pre><code>- str_to_date\n- date_formate\n</code></pre><p>3、str_to_date<br>    3.1 该函数作用：将’日期字符串‘转换成’日期类型‘数据。[varchar–&gt;date]<br>    3.2 该函数的执行结果是DATE类型<br>    3.3 格式：<br>        str_to_date(‘日期字符串’,’日期格式’)<br>","more":"<br>    3.4 MYSQL日期格式：<br>        %Y    年<br>        %M  月<br>        %d  日<br>        %H  时<br>        %i  分<br>        %s  秒</p>\n<pre><code>3.5 例：查询出1980-12-17入职的员工\n\n    mysql&gt; select ename,hiredate from emp where hiredate=&apos;1980-12-17&apos;;\n    +--------+------------+\n    | ename  | hiredate   |\n    +--------+------------+\n    | SIMITH | 1980-12-17 |\n    +--------+------------+\n    MYSQL默认的日期格式%Y-%m-%d,以上的日期字符串’1980-12-17‘正好和默认的日期格式一样，存在了自动类型转换，自动将日期字符串转换成了日期类型，所以以上查询可以查询出结果。\n\n    mysql&gt; select ename,hiredate from emp where hiredate=&apos;12-17-1980&apos;;\n    Empty set, 2 warnings (0.00 sec)\n    &apos;12-17-1980&apos; 日期字符串和MYSQL默认的日期格式不同\n    hiredate是DATE类型，&apos;12-17-1980&apos;是一个字符串varchar类型，类型不匹配。所以无法查询结果，会有错误发生。\n\n    纠正以上错误：\n    mysql&gt; select ename,hiredate from emp where hiredate=str_to_date(&apos;12-17-1980&apos;,&apos;%m-%d-%Y&apos;);\n    +--------+------------+\n    | ename  | hiredate   |\n    +--------+------------+\n    | SIMITH | 1980-12-17 |\n    +--------+------------+\n\n3.6例：\n创建学生表：\ncreate table t_student(\n    id int(10),\n    name varchar(32),\n    birth date\n);\n\n插入数据：\ninsert into t_student(id,name,birth) values(1,&apos;jack&apos;,&apos;1980-10-11&apos;);\n以上可以执行，因为格式和默认日期格式相同，所以自动转换类型。\n\ninsert into t_student(id,name,birth) values(2,&apos;road&apos;,&apos;10-15-1982&apos;);\nERROR 1292 (22007): Incorrect date value: &apos;10-15-1982&apos; for column &apos;birth&apos; at row 1\n以上发生错误：\n    1、和默认格式不同\n    2、&apos;10-15-1982&apos;是varchar类型，和DATE类型不同\n\n纠正：\ninsert into t_student(id,name,birth) values(2,&apos;road&apos;,str_to_date(&apos;10-15-1982&apos;,&apos;%m-%d-%Y&apos;));\n</code></pre><p>4、date_format<br>    4.1 作用：将日期类型DATE转换成具有特定格式的日期字符串varchar[date–&gt;varchar]</p>\n<pre><code>4.2 运算结果：varchar类型\n\n4.3 语法格式：\n    date_format(日期类型数据，&apos;日期格式&apos;)\n\n4.4 例：查询员工的入职日期，以‘%m-%d-%Y’的格式显示到窗口中\nmysql&gt; select ename,date_format(hiredate,&apos;%m-%d-%Y&apos;) hiredate from emp;\n+--------+------------+\n| ename  | hiredate   |\n+--------+------------+\n| SIMITH | 12-17-1980 |\n| ALLEN  | 02-20-1981 |\n| WARD   | 02-22-1981 |\n| JONES  | 04-02-1981 |\n| MARTIN | 09-28-1981 |\n| BLAKE  | 05-01-1981 |\n| CLARK  | 06-09-1981 |\n| SCOTT  | 04-19-1987 |\n| KING   | 11-17-1981 |\n| TURNER | 09-08-1981 |\n| ADAMS  | 05-23-1987 |\n| JAMES  | 12-03-1981 |\n| FORD   | 12-03-1981 |\n| MILLER | 01-23-1982 |\n+--------+------------+\n</code></pre>"},{"title":"MYSQL数据库笔记_4之连接查询","date":"2018-08-10T08:17:36.000Z","_content":"\n连接查询\n\n1、什么是连接查询？\n\t- 查询的时候只从一张表检索数据，被称为单表查询\n\t\n\t- 在实际的开发中，数据并不是存储在一张表中的，是同时存储在多张表中，这些表和表之间存在关系，我们在检索的时候通常是需要将多张表联合起来取得有效数据，这种多表查询被称为连接查询或跨表查询。\n\n2、根据年代分类：\n\t- SQL92\n\t- SQL99：更新语法，主要掌握\n\tSQL92需要能看懂\n<!--more-->\n3、连接查询根据连接方式分类：\n\t- 内连接：\n\t\t*等值连接\n\t\t*非等值连接\n\t\t*自连接\n\n\t- 外连接\n\t\t*左外连接(左连接)\n\t\t*右外连接(右连接)\n\n\t- 全连接(暂时不掌握，很少使用)\n\n4、当多第表进行连接查询，若没有任何条件进行限制，会发生什么现象？\n\t例：查询每一个员工所在的部门名称，要求最终显示员工名和对应部门名。\n\nmysql> select deptno,ename from emp; 员工表\n+--------+--------+\n| deptno | ename  |\n+--------+--------+\n|     20 | SIMITH |\n|     30 | ALLEN  |\n|     30 | WARD   |\n|     20 | JONES  |\n|     30 | MARTIN |\n|     30 | BLAKE  |\n|     10 | CLARK  |\n|     20 | SCOTT  |\n|     10 | KING   |\n|     30 | TURNER |\n|     20 | ADAMS  |\n|     30 | JAMES  |\n|     20 | FORD   |\n|     10 | MILLER |\n+--------+--------+\n\nmysql> select deptno,dname from dept; 部门表\n+--------+-------------+\n| deptno | dname       |\n+--------+-------------+\n|     10 | ACCOUNTING  |\n|     20 | RESEARCHING |\n|     30 | SALES       |\n|     40 | OPERATONS   |\n+--------+-------------+\n\n主要分析：多张表连接查询，若没有任何条件限制，会发生什么？\n\n小知识： 在进行多表连接查询时，尽量给表起别名，这样效率高，可读性高。\nmysql> select e.ename,d.dname from emp e,dept d;\n+--------+-------------+\n| ename  | dname       |\n+--------+-------------+\n| SIMITH | ACCOUNTING  |\n| SIMITH | RESEARCHING |\n| SIMITH | SALES       |\n| SIMITH | OPERATONS   |\n| ALLEN  | ACCOUNTING  |\n| ALLEN  | RESEARCHING |\n| ALLEN  | SALES       |\n| ALLEN  | OPERATONS   |\n| WARD   | ACCOUNTING  |\n| WARD   | RESEARCHING |\n| WARD   | SALES       |\n| WARD   | OPERATONS   |\n| JONES  | ACCOUNTING  |\n| JONES  | RESEARCHING |\n| JONES  | SALES       |\n| JONES  | OPERATONS   |\n|..................... |\n+--------+-------------+\n56 rows in set\n\n结论：若两张表进行连接查询的时候没有任何条件限制，最终的查询结果总数是两张表记录条数乘积，需要添加限制条件。\n\n\n例：查询每一个员工所在的部门名称，要求最终显示员工名和对应部门名。\n\nmysql> select deptno,ename from emp; 员工表\n+--------+--------+\n| deptno | ename  |\n+--------+--------+\n|     20 | SIMITH |\n|     30 | ALLEN  |\n|     30 | WARD   |\n|     20 | JONES  |\n|     30 | MARTIN |\n|     30 | BLAKE  |\n|     10 | CLARK  |\n|     20 | SCOTT  |\n|     10 | KING   |\n|     30 | TURNER |\n|     20 | ADAMS  |\n|     30 | JAMES  |\n|     20 | FORD   |\n|     10 | MILLER |\n+--------+--------+\n\nmysql> select deptno,dname from dept; 部门表\n+--------+-------------+\n| deptno | dname       |\n+--------+-------------+\n|     10 | ACCOUNTING  |\n|     20 | RESEARCHING |\n|     30 | SALES       |\n|     40 | OPERATONS   |\n+--------+-------------+\n\n注：在连接查询的时候虽然使用了限制条件，但是匹配的次数没有减少，还是56次，只不过这一次的结果都是有效记录。\n\nSQL92语法：内连接中的等值连接\nmysql> select e.ename,d.dname from emp e,dept d where e.deptno=d.deptno;\n\nSQL99语法：内连接中的等值连接\nmysql> select e.ename,d.dname from emp e join dept d on e.deptno=d.deptno;\n或者\nmysql> select e.ename,d.dname from emp e inner join dept d on e.deptno=d.deptno; //inner可以省略\n\nSQL99语法：表连接独立出来了，结构更清晰。对表连接不满意的话，还要以再追加where进行过滤。\n+--------+-------------+\n| ename  | dname       |\n+--------+-------------+\n| SIMITH | RESEARCHING |\n| ALLEN  | SALES       |\n| WARD   | SALES       |\n| JONES  | RESEARCHING |\n| MARTIN | SALES       |\n| BLAKE  | SALES       |\n| CLARK  | ACCOUNTING  |\n| SCOTT  | RESEARCHING |\n| KING   | ACCOUNTING  |\n| TURNER | SALES       |\n| ADAMS  | RESEARCHING |\n| JAMES  | SALES       |\n| FORD   | RESEARCHING |\n| MILLER | ACCOUNTING  |\n+--------+-------------+\n\n\n5、例：找出每一个员工对应的工资等级，要求显示员工名，工资，工资等级\n\nSQL99语法：内连接中的非等值连接\nmysql> select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;\n+--------+---------+-------+\n| ename  | sal     | grade |\n+--------+---------+-------+\n| SIMITH |  800.00 |     1 |\n| ALLEN  | 1600.00 |     3 |\n| WARD   | 1250.00 |     2 |\n| JONES  | 2975.00 |     4 |\n| MARTIN | 1250.00 |     2 |\n| BLAKE  | 2850.00 |     4 |\n| CLARK  | 2450.00 |     4 |\n| SCOTT  | 3000.00 |     4 |\n| KING   | 5000.00 |     5 |\n| TURNER | 1500.00 |     3 |\n| ADAMS  | 1100.00 |     1 |\n| JAMES  |  950.00 |     1 |\n| FORD   | 3000.00 |     4 |\n| MILLER | 1300.00 |     2 |\n+--------+---------+-------+\n\n\n6、找出每一个员工的上级领导，要求显示员工名以及对应的上级领导名称\nemp a<员工表>\nemp b<领导表>\n条件：a.mgr=b.empno\n\nSQL99语法：内连接中的自连接\nmysql> select a.ename empname,b.ename leadername from emp a join emp b on a.mgr=b.empno;\n+---------+------------+\n| empname | leadername |\n+---------+------------+\n| SIMITH  | FORD       |\n| ALLEN   | BLAKE      |\n| WARD    | BLAKE      |\n| JONES   | KING       |\n| MARTIN  | BLAKE      |\n| BLAKE   | KING       |\n| CLARK   | KING       |\n| SCOTT   | JONES      |\n| TURNER  | BLAKE      |\n| ADAMS   | SCOTT      |\n| JAMES   | BLAKE      |\n| FORD    | JONES      |\n| MILLER  | CLARK      |\n+---------+------------+\n\n\n7、例：找出每一个员工对应的部门名称,要求显示全部部门\n\n内连接：A表和B能够完全匹配的记录查询出来，称为内连接\n\n外连接：A表和B表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的完全查询出来，对方表没有匹配的记录，会自动模拟出NULL与之匹配，称为外连接。\n\n外连接的查询结果条数 >= 内连接的查询结果条数\n\n\nSQL99语法：外连接中的右外连接\nmysql> select e.ename,d.dname from emp e right outter join dept d on e.deptno=d.deptno;//outer可以省略\nmysql> select e.ename,d.dname from emp e right join dept d on e.deptno=d.deptno;\n\nSQL99语法：外连接中的左外连接\nmysql> select e.ename,d.dname from dept d left outter join emp e on e.deptno=d.deptno;//outer可以省略\nmysql> select e.ename,d.dname from dept d left join emp e on e.deptno=d.deptno; \n\n注：任何一个右外连接都可以写左外连接，反之也可以\n\n+--------+-------------+\n| ename  | dname       |\n+--------+-------------+\n| SIMITH | RESEARCHING |\n| ALLEN  | SALES       |\n| WARD   | SALES       |\n| JONES  | RESEARCHING |\n| MARTIN | SALES       |\n| BLAKE  | SALES       |\n| CLARK  | ACCOUNTING  |\n| SCOTT  | RESEARCHING |\n| KING   | ACCOUNTING  |\n| TURNER | SALES       |\n| ADAMS  | RESEARCHING |\n| JAMES  | SALES       |\n| FORD   | RESEARCHING |\n| MILLER | ACCOUNTING  |\n| NULL   | OPERATONS   |\n+--------+-------------+\n\n为什么inner和outter可以省略，加上去有什么好处？\n\t- 可以省略，国为区分内连接和外连接依靠的不是这些关键字，而是看SQL语句中是否存在left/right，若存在，表示一定是一个外连接，其他都是内连接。\n\n\t- 加上去的好处是增强可读性\n\n\n8、例：找出每一个员工对应领导名，要求显示所有的员工\nmysql> select a.ename empname,b.ename leadername from emp a left join emp b on a.mgr=b.empno;\n+---------+------------+\n| empname | leadername |\n+---------+------------+\n| SIMITH  | FORD       |\n| ALLEN   | BLAKE      |\n| WARD    | BLAKE      |\n| JONES   | KING       |\n| MARTIN  | BLAKE      |\n| BLAKE   | KING       |\n| CLARK   | KING       |\n| SCOTT   | JONES      |\n| KING    | NULL       |\n| TURNER  | BLAKE      |\n| ADAMS   | SCOTT      |\n| JAMES   | BLAKE      |\n| FORD    | JONES      |\n| MILLER  | CLARK      |\n+---------+------------+\n\n\n9、例：找出每一个员工对应的部门名称，以及该员工对应的工资等级。要求显示员工名、部门名、工资等级。\nmysql> select e.ename,d.dname,s.grade from emp e  join dept d on e.deptno=d.deptno join salgrade s on e.sal between s.losal and s.hisal;\n+--------+-------------+-------+\n| ename  | dname       | grade |\n+--------+-------------+-------+\n| SIMITH | RESEARCHING |     1 |\n| ALLEN  | SALES       |     3 |\n| WARD   | SALES       |     2 |\n| JONES  | RESEARCHING |     4 |\n| MARTIN | SALES       |     2 |\n| BLAKE  | SALES       |     4 |\n| CLARK  | ACCOUNTING  |     4 |\n| SCOTT  | RESEARCHING |     4 |\n| KING   | ACCOUNTING  |     5 |\n| TURNER | SALES       |     3 |\n| ADAMS  | RESEARCHING |     1 |\n| JAMES  | SALES       |     1 |\n| FORD   | RESEARCHING |     4 |\n| MILLER | ACCOUNTING  |     2 |\n+--------+-------------+-------+\n\n多张表进行表连接的语法格式：\nselect \n\t...\nfrom\n\ta\njoin\n\tb\non\n\t条件\njoin\n\tc\non\n\t条件\n\n原理：a和b先进行表连接，接着a和c再进行表连接。\n","source":"_posts/MYSQL数据库笔记-4之连接查询.md","raw":"---\ntitle: MYSQL数据库笔记_4之连接查询\ndate: 2018-08-10 16:17:36\ntags:\n---\n\n连接查询\n\n1、什么是连接查询？\n\t- 查询的时候只从一张表检索数据，被称为单表查询\n\t\n\t- 在实际的开发中，数据并不是存储在一张表中的，是同时存储在多张表中，这些表和表之间存在关系，我们在检索的时候通常是需要将多张表联合起来取得有效数据，这种多表查询被称为连接查询或跨表查询。\n\n2、根据年代分类：\n\t- SQL92\n\t- SQL99：更新语法，主要掌握\n\tSQL92需要能看懂\n<!--more-->\n3、连接查询根据连接方式分类：\n\t- 内连接：\n\t\t*等值连接\n\t\t*非等值连接\n\t\t*自连接\n\n\t- 外连接\n\t\t*左外连接(左连接)\n\t\t*右外连接(右连接)\n\n\t- 全连接(暂时不掌握，很少使用)\n\n4、当多第表进行连接查询，若没有任何条件进行限制，会发生什么现象？\n\t例：查询每一个员工所在的部门名称，要求最终显示员工名和对应部门名。\n\nmysql> select deptno,ename from emp; 员工表\n+--------+--------+\n| deptno | ename  |\n+--------+--------+\n|     20 | SIMITH |\n|     30 | ALLEN  |\n|     30 | WARD   |\n|     20 | JONES  |\n|     30 | MARTIN |\n|     30 | BLAKE  |\n|     10 | CLARK  |\n|     20 | SCOTT  |\n|     10 | KING   |\n|     30 | TURNER |\n|     20 | ADAMS  |\n|     30 | JAMES  |\n|     20 | FORD   |\n|     10 | MILLER |\n+--------+--------+\n\nmysql> select deptno,dname from dept; 部门表\n+--------+-------------+\n| deptno | dname       |\n+--------+-------------+\n|     10 | ACCOUNTING  |\n|     20 | RESEARCHING |\n|     30 | SALES       |\n|     40 | OPERATONS   |\n+--------+-------------+\n\n主要分析：多张表连接查询，若没有任何条件限制，会发生什么？\n\n小知识： 在进行多表连接查询时，尽量给表起别名，这样效率高，可读性高。\nmysql> select e.ename,d.dname from emp e,dept d;\n+--------+-------------+\n| ename  | dname       |\n+--------+-------------+\n| SIMITH | ACCOUNTING  |\n| SIMITH | RESEARCHING |\n| SIMITH | SALES       |\n| SIMITH | OPERATONS   |\n| ALLEN  | ACCOUNTING  |\n| ALLEN  | RESEARCHING |\n| ALLEN  | SALES       |\n| ALLEN  | OPERATONS   |\n| WARD   | ACCOUNTING  |\n| WARD   | RESEARCHING |\n| WARD   | SALES       |\n| WARD   | OPERATONS   |\n| JONES  | ACCOUNTING  |\n| JONES  | RESEARCHING |\n| JONES  | SALES       |\n| JONES  | OPERATONS   |\n|..................... |\n+--------+-------------+\n56 rows in set\n\n结论：若两张表进行连接查询的时候没有任何条件限制，最终的查询结果总数是两张表记录条数乘积，需要添加限制条件。\n\n\n例：查询每一个员工所在的部门名称，要求最终显示员工名和对应部门名。\n\nmysql> select deptno,ename from emp; 员工表\n+--------+--------+\n| deptno | ename  |\n+--------+--------+\n|     20 | SIMITH |\n|     30 | ALLEN  |\n|     30 | WARD   |\n|     20 | JONES  |\n|     30 | MARTIN |\n|     30 | BLAKE  |\n|     10 | CLARK  |\n|     20 | SCOTT  |\n|     10 | KING   |\n|     30 | TURNER |\n|     20 | ADAMS  |\n|     30 | JAMES  |\n|     20 | FORD   |\n|     10 | MILLER |\n+--------+--------+\n\nmysql> select deptno,dname from dept; 部门表\n+--------+-------------+\n| deptno | dname       |\n+--------+-------------+\n|     10 | ACCOUNTING  |\n|     20 | RESEARCHING |\n|     30 | SALES       |\n|     40 | OPERATONS   |\n+--------+-------------+\n\n注：在连接查询的时候虽然使用了限制条件，但是匹配的次数没有减少，还是56次，只不过这一次的结果都是有效记录。\n\nSQL92语法：内连接中的等值连接\nmysql> select e.ename,d.dname from emp e,dept d where e.deptno=d.deptno;\n\nSQL99语法：内连接中的等值连接\nmysql> select e.ename,d.dname from emp e join dept d on e.deptno=d.deptno;\n或者\nmysql> select e.ename,d.dname from emp e inner join dept d on e.deptno=d.deptno; //inner可以省略\n\nSQL99语法：表连接独立出来了，结构更清晰。对表连接不满意的话，还要以再追加where进行过滤。\n+--------+-------------+\n| ename  | dname       |\n+--------+-------------+\n| SIMITH | RESEARCHING |\n| ALLEN  | SALES       |\n| WARD   | SALES       |\n| JONES  | RESEARCHING |\n| MARTIN | SALES       |\n| BLAKE  | SALES       |\n| CLARK  | ACCOUNTING  |\n| SCOTT  | RESEARCHING |\n| KING   | ACCOUNTING  |\n| TURNER | SALES       |\n| ADAMS  | RESEARCHING |\n| JAMES  | SALES       |\n| FORD   | RESEARCHING |\n| MILLER | ACCOUNTING  |\n+--------+-------------+\n\n\n5、例：找出每一个员工对应的工资等级，要求显示员工名，工资，工资等级\n\nSQL99语法：内连接中的非等值连接\nmysql> select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;\n+--------+---------+-------+\n| ename  | sal     | grade |\n+--------+---------+-------+\n| SIMITH |  800.00 |     1 |\n| ALLEN  | 1600.00 |     3 |\n| WARD   | 1250.00 |     2 |\n| JONES  | 2975.00 |     4 |\n| MARTIN | 1250.00 |     2 |\n| BLAKE  | 2850.00 |     4 |\n| CLARK  | 2450.00 |     4 |\n| SCOTT  | 3000.00 |     4 |\n| KING   | 5000.00 |     5 |\n| TURNER | 1500.00 |     3 |\n| ADAMS  | 1100.00 |     1 |\n| JAMES  |  950.00 |     1 |\n| FORD   | 3000.00 |     4 |\n| MILLER | 1300.00 |     2 |\n+--------+---------+-------+\n\n\n6、找出每一个员工的上级领导，要求显示员工名以及对应的上级领导名称\nemp a<员工表>\nemp b<领导表>\n条件：a.mgr=b.empno\n\nSQL99语法：内连接中的自连接\nmysql> select a.ename empname,b.ename leadername from emp a join emp b on a.mgr=b.empno;\n+---------+------------+\n| empname | leadername |\n+---------+------------+\n| SIMITH  | FORD       |\n| ALLEN   | BLAKE      |\n| WARD    | BLAKE      |\n| JONES   | KING       |\n| MARTIN  | BLAKE      |\n| BLAKE   | KING       |\n| CLARK   | KING       |\n| SCOTT   | JONES      |\n| TURNER  | BLAKE      |\n| ADAMS   | SCOTT      |\n| JAMES   | BLAKE      |\n| FORD    | JONES      |\n| MILLER  | CLARK      |\n+---------+------------+\n\n\n7、例：找出每一个员工对应的部门名称,要求显示全部部门\n\n内连接：A表和B能够完全匹配的记录查询出来，称为内连接\n\n外连接：A表和B表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的完全查询出来，对方表没有匹配的记录，会自动模拟出NULL与之匹配，称为外连接。\n\n外连接的查询结果条数 >= 内连接的查询结果条数\n\n\nSQL99语法：外连接中的右外连接\nmysql> select e.ename,d.dname from emp e right outter join dept d on e.deptno=d.deptno;//outer可以省略\nmysql> select e.ename,d.dname from emp e right join dept d on e.deptno=d.deptno;\n\nSQL99语法：外连接中的左外连接\nmysql> select e.ename,d.dname from dept d left outter join emp e on e.deptno=d.deptno;//outer可以省略\nmysql> select e.ename,d.dname from dept d left join emp e on e.deptno=d.deptno; \n\n注：任何一个右外连接都可以写左外连接，反之也可以\n\n+--------+-------------+\n| ename  | dname       |\n+--------+-------------+\n| SIMITH | RESEARCHING |\n| ALLEN  | SALES       |\n| WARD   | SALES       |\n| JONES  | RESEARCHING |\n| MARTIN | SALES       |\n| BLAKE  | SALES       |\n| CLARK  | ACCOUNTING  |\n| SCOTT  | RESEARCHING |\n| KING   | ACCOUNTING  |\n| TURNER | SALES       |\n| ADAMS  | RESEARCHING |\n| JAMES  | SALES       |\n| FORD   | RESEARCHING |\n| MILLER | ACCOUNTING  |\n| NULL   | OPERATONS   |\n+--------+-------------+\n\n为什么inner和outter可以省略，加上去有什么好处？\n\t- 可以省略，国为区分内连接和外连接依靠的不是这些关键字，而是看SQL语句中是否存在left/right，若存在，表示一定是一个外连接，其他都是内连接。\n\n\t- 加上去的好处是增强可读性\n\n\n8、例：找出每一个员工对应领导名，要求显示所有的员工\nmysql> select a.ename empname,b.ename leadername from emp a left join emp b on a.mgr=b.empno;\n+---------+------------+\n| empname | leadername |\n+---------+------------+\n| SIMITH  | FORD       |\n| ALLEN   | BLAKE      |\n| WARD    | BLAKE      |\n| JONES   | KING       |\n| MARTIN  | BLAKE      |\n| BLAKE   | KING       |\n| CLARK   | KING       |\n| SCOTT   | JONES      |\n| KING    | NULL       |\n| TURNER  | BLAKE      |\n| ADAMS   | SCOTT      |\n| JAMES   | BLAKE      |\n| FORD    | JONES      |\n| MILLER  | CLARK      |\n+---------+------------+\n\n\n9、例：找出每一个员工对应的部门名称，以及该员工对应的工资等级。要求显示员工名、部门名、工资等级。\nmysql> select e.ename,d.dname,s.grade from emp e  join dept d on e.deptno=d.deptno join salgrade s on e.sal between s.losal and s.hisal;\n+--------+-------------+-------+\n| ename  | dname       | grade |\n+--------+-------------+-------+\n| SIMITH | RESEARCHING |     1 |\n| ALLEN  | SALES       |     3 |\n| WARD   | SALES       |     2 |\n| JONES  | RESEARCHING |     4 |\n| MARTIN | SALES       |     2 |\n| BLAKE  | SALES       |     4 |\n| CLARK  | ACCOUNTING  |     4 |\n| SCOTT  | RESEARCHING |     4 |\n| KING   | ACCOUNTING  |     5 |\n| TURNER | SALES       |     3 |\n| ADAMS  | RESEARCHING |     1 |\n| JAMES  | SALES       |     1 |\n| FORD   | RESEARCHING |     4 |\n| MILLER | ACCOUNTING  |     2 |\n+--------+-------------+-------+\n\n多张表进行表连接的语法格式：\nselect \n\t...\nfrom\n\ta\njoin\n\tb\non\n\t条件\njoin\n\tc\non\n\t条件\n\n原理：a和b先进行表连接，接着a和c再进行表连接。\n","slug":"MYSQL数据库笔记-4之连接查询","published":1,"updated":"2018-09-13T12:41:24.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm0r966e0003mlfiawo0wk9g","content":"<p>连接查询</p>\n<p>1、什么是连接查询？</p>\n<pre><code>- 查询的时候只从一张表检索数据，被称为单表查询\n\n- 在实际的开发中，数据并不是存储在一张表中的，是同时存储在多张表中，这些表和表之间存在关系，我们在检索的时候通常是需要将多张表联合起来取得有效数据，这种多表查询被称为连接查询或跨表查询。\n</code></pre><p>2、根据年代分类：</p>\n<pre><code>- SQL92\n- SQL99：更新语法，主要掌握\nSQL92需要能看懂\n</code></pre><a id=\"more\"></a>\n<p>3、连接查询根据连接方式分类：</p>\n<pre><code>- 内连接：\n    *等值连接\n    *非等值连接\n    *自连接\n\n- 外连接\n    *左外连接(左连接)\n    *右外连接(右连接)\n\n- 全连接(暂时不掌握，很少使用)\n</code></pre><p>4、当多第表进行连接查询，若没有任何条件进行限制，会发生什么现象？<br>    例：查询每一个员工所在的部门名称，要求最终显示员工名和对应部门名。</p>\n<p>mysql&gt; select deptno,ename from emp; 员工表<br>+——–+——–+<br>| deptno | ename  |<br>+——–+——–+<br>|     20 | SIMITH |<br>|     30 | ALLEN  |<br>|     30 | WARD   |<br>|     20 | JONES  |<br>|     30 | MARTIN |<br>|     30 | BLAKE  |<br>|     10 | CLARK  |<br>|     20 | SCOTT  |<br>|     10 | KING   |<br>|     30 | TURNER |<br>|     20 | ADAMS  |<br>|     30 | JAMES  |<br>|     20 | FORD   |<br>|     10 | MILLER |<br>+——–+——–+</p>\n<p>mysql&gt; select deptno,dname from dept; 部门表<br>+——–+————-+<br>| deptno | dname       |<br>+——–+————-+<br>|     10 | ACCOUNTING  |<br>|     20 | RESEARCHING |<br>|     30 | SALES       |<br>|     40 | OPERATONS   |<br>+——–+————-+</p>\n<p>主要分析：多张表连接查询，若没有任何条件限制，会发生什么？</p>\n<p>小知识： 在进行多表连接查询时，尽量给表起别名，这样效率高，可读性高。<br>mysql&gt; select e.ename,d.dname from emp e,dept d;<br>+——–+————-+<br>| ename  | dname       |<br>+——–+————-+<br>| SIMITH | ACCOUNTING  |<br>| SIMITH | RESEARCHING |<br>| SIMITH | SALES       |<br>| SIMITH | OPERATONS   |<br>| ALLEN  | ACCOUNTING  |<br>| ALLEN  | RESEARCHING |<br>| ALLEN  | SALES       |<br>| ALLEN  | OPERATONS   |<br>| WARD   | ACCOUNTING  |<br>| WARD   | RESEARCHING |<br>| WARD   | SALES       |<br>| WARD   | OPERATONS   |<br>| JONES  | ACCOUNTING  |<br>| JONES  | RESEARCHING |<br>| JONES  | SALES       |<br>| JONES  | OPERATONS   |<br>|………………… |<br>+——–+————-+<br>56 rows in set</p>\n<p>结论：若两张表进行连接查询的时候没有任何条件限制，最终的查询结果总数是两张表记录条数乘积，需要添加限制条件。</p>\n<p>例：查询每一个员工所在的部门名称，要求最终显示员工名和对应部门名。</p>\n<p>mysql&gt; select deptno,ename from emp; 员工表<br>+——–+——–+<br>| deptno | ename  |<br>+——–+——–+<br>|     20 | SIMITH |<br>|     30 | ALLEN  |<br>|     30 | WARD   |<br>|     20 | JONES  |<br>|     30 | MARTIN |<br>|     30 | BLAKE  |<br>|     10 | CLARK  |<br>|     20 | SCOTT  |<br>|     10 | KING   |<br>|     30 | TURNER |<br>|     20 | ADAMS  |<br>|     30 | JAMES  |<br>|     20 | FORD   |<br>|     10 | MILLER |<br>+——–+——–+</p>\n<p>mysql&gt; select deptno,dname from dept; 部门表<br>+——–+————-+<br>| deptno | dname       |<br>+——–+————-+<br>|     10 | ACCOUNTING  |<br>|     20 | RESEARCHING |<br>|     30 | SALES       |<br>|     40 | OPERATONS   |<br>+——–+————-+</p>\n<p>注：在连接查询的时候虽然使用了限制条件，但是匹配的次数没有减少，还是56次，只不过这一次的结果都是有效记录。</p>\n<p>SQL92语法：内连接中的等值连接<br>mysql&gt; select e.ename,d.dname from emp e,dept d where e.deptno=d.deptno;</p>\n<p>SQL99语法：内连接中的等值连接<br>mysql&gt; select e.ename,d.dname from emp e join dept d on e.deptno=d.deptno;<br>或者<br>mysql&gt; select e.ename,d.dname from emp e inner join dept d on e.deptno=d.deptno; //inner可以省略</p>\n<p>SQL99语法：表连接独立出来了，结构更清晰。对表连接不满意的话，还要以再追加where进行过滤。<br>+——–+————-+<br>| ename  | dname       |<br>+——–+————-+<br>| SIMITH | RESEARCHING |<br>| ALLEN  | SALES       |<br>| WARD   | SALES       |<br>| JONES  | RESEARCHING |<br>| MARTIN | SALES       |<br>| BLAKE  | SALES       |<br>| CLARK  | ACCOUNTING  |<br>| SCOTT  | RESEARCHING |<br>| KING   | ACCOUNTING  |<br>| TURNER | SALES       |<br>| ADAMS  | RESEARCHING |<br>| JAMES  | SALES       |<br>| FORD   | RESEARCHING |<br>| MILLER | ACCOUNTING  |<br>+——–+————-+</p>\n<p>5、例：找出每一个员工对应的工资等级，要求显示员工名，工资，工资等级</p>\n<p>SQL99语法：内连接中的非等值连接<br>mysql&gt; select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;<br>+——–+———+——-+<br>| ename  | sal     | grade |<br>+——–+———+——-+<br>| SIMITH |  800.00 |     1 |<br>| ALLEN  | 1600.00 |     3 |<br>| WARD   | 1250.00 |     2 |<br>| JONES  | 2975.00 |     4 |<br>| MARTIN | 1250.00 |     2 |<br>| BLAKE  | 2850.00 |     4 |<br>| CLARK  | 2450.00 |     4 |<br>| SCOTT  | 3000.00 |     4 |<br>| KING   | 5000.00 |     5 |<br>| TURNER | 1500.00 |     3 |<br>| ADAMS  | 1100.00 |     1 |<br>| JAMES  |  950.00 |     1 |<br>| FORD   | 3000.00 |     4 |<br>| MILLER | 1300.00 |     2 |<br>+——–+———+——-+</p>\n<p>6、找出每一个员工的上级领导，要求显示员工名以及对应的上级领导名称<br>emp a&lt;员工表&gt;<br>emp b&lt;领导表&gt;<br>条件：a.mgr=b.empno</p>\n<p>SQL99语法：内连接中的自连接<br>mysql&gt; select a.ename empname,b.ename leadername from emp a join emp b on a.mgr=b.empno;<br>+———+————+<br>| empname | leadername |<br>+———+————+<br>| SIMITH  | FORD       |<br>| ALLEN   | BLAKE      |<br>| WARD    | BLAKE      |<br>| JONES   | KING       |<br>| MARTIN  | BLAKE      |<br>| BLAKE   | KING       |<br>| CLARK   | KING       |<br>| SCOTT   | JONES      |<br>| TURNER  | BLAKE      |<br>| ADAMS   | SCOTT      |<br>| JAMES   | BLAKE      |<br>| FORD    | JONES      |<br>| MILLER  | CLARK      |<br>+———+————+</p>\n<p>7、例：找出每一个员工对应的部门名称,要求显示全部部门</p>\n<p>内连接：A表和B能够完全匹配的记录查询出来，称为内连接</p>\n<p>外连接：A表和B表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的完全查询出来，对方表没有匹配的记录，会自动模拟出NULL与之匹配，称为外连接。</p>\n<p>外连接的查询结果条数 &gt;= 内连接的查询结果条数</p>\n<p>SQL99语法：外连接中的右外连接<br>mysql&gt; select e.ename,d.dname from emp e right outter join dept d on e.deptno=d.deptno;//outer可以省略<br>mysql&gt; select e.ename,d.dname from emp e right join dept d on e.deptno=d.deptno;</p>\n<p>SQL99语法：外连接中的左外连接<br>mysql&gt; select e.ename,d.dname from dept d left outter join emp e on e.deptno=d.deptno;//outer可以省略<br>mysql&gt; select e.ename,d.dname from dept d left join emp e on e.deptno=d.deptno; </p>\n<p>注：任何一个右外连接都可以写左外连接，反之也可以</p>\n<p>+——–+————-+<br>| ename  | dname       |<br>+——–+————-+<br>| SIMITH | RESEARCHING |<br>| ALLEN  | SALES       |<br>| WARD   | SALES       |<br>| JONES  | RESEARCHING |<br>| MARTIN | SALES       |<br>| BLAKE  | SALES       |<br>| CLARK  | ACCOUNTING  |<br>| SCOTT  | RESEARCHING |<br>| KING   | ACCOUNTING  |<br>| TURNER | SALES       |<br>| ADAMS  | RESEARCHING |<br>| JAMES  | SALES       |<br>| FORD   | RESEARCHING |<br>| MILLER | ACCOUNTING  |<br>| NULL   | OPERATONS   |<br>+——–+————-+</p>\n<p>为什么inner和outter可以省略，加上去有什么好处？</p>\n<pre><code>- 可以省略，国为区分内连接和外连接依靠的不是这些关键字，而是看SQL语句中是否存在left/right，若存在，表示一定是一个外连接，其他都是内连接。\n\n- 加上去的好处是增强可读性\n</code></pre><p>8、例：找出每一个员工对应领导名，要求显示所有的员工<br>mysql&gt; select a.ename empname,b.ename leadername from emp a left join emp b on a.mgr=b.empno;<br>+———+————+<br>| empname | leadername |<br>+———+————+<br>| SIMITH  | FORD       |<br>| ALLEN   | BLAKE      |<br>| WARD    | BLAKE      |<br>| JONES   | KING       |<br>| MARTIN  | BLAKE      |<br>| BLAKE   | KING       |<br>| CLARK   | KING       |<br>| SCOTT   | JONES      |<br>| KING    | NULL       |<br>| TURNER  | BLAKE      |<br>| ADAMS   | SCOTT      |<br>| JAMES   | BLAKE      |<br>| FORD    | JONES      |<br>| MILLER  | CLARK      |<br>+———+————+</p>\n<p>9、例：找出每一个员工对应的部门名称，以及该员工对应的工资等级。要求显示员工名、部门名、工资等级。<br>mysql&gt; select e.ename,d.dname,s.grade from emp e  join dept d on e.deptno=d.deptno join salgrade s on e.sal between s.losal and s.hisal;<br>+——–+————-+——-+<br>| ename  | dname       | grade |<br>+——–+————-+——-+<br>| SIMITH | RESEARCHING |     1 |<br>| ALLEN  | SALES       |     3 |<br>| WARD   | SALES       |     2 |<br>| JONES  | RESEARCHING |     4 |<br>| MARTIN | SALES       |     2 |<br>| BLAKE  | SALES       |     4 |<br>| CLARK  | ACCOUNTING  |     4 |<br>| SCOTT  | RESEARCHING |     4 |<br>| KING   | ACCOUNTING  |     5 |<br>| TURNER | SALES       |     3 |<br>| ADAMS  | RESEARCHING |     1 |<br>| JAMES  | SALES       |     1 |<br>| FORD   | RESEARCHING |     4 |<br>| MILLER | ACCOUNTING  |     2 |<br>+——–+————-+——-+</p>\n<p>多张表进行表连接的语法格式：<br>select<br>    …<br>from<br>    a<br>join<br>    b<br>on<br>    条件<br>join<br>    c<br>on<br>    条件</p>\n<p>原理：a和b先进行表连接，接着a和c再进行表连接。</p>\n","site":{"data":{}},"excerpt":"<p>连接查询</p>\n<p>1、什么是连接查询？</p>\n<pre><code>- 查询的时候只从一张表检索数据，被称为单表查询\n\n- 在实际的开发中，数据并不是存储在一张表中的，是同时存储在多张表中，这些表和表之间存在关系，我们在检索的时候通常是需要将多张表联合起来取得有效数据，这种多表查询被称为连接查询或跨表查询。\n</code></pre><p>2、根据年代分类：</p>\n<pre><code>- SQL92\n- SQL99：更新语法，主要掌握\nSQL92需要能看懂\n</code></pre>","more":"<p>3、连接查询根据连接方式分类：</p>\n<pre><code>- 内连接：\n    *等值连接\n    *非等值连接\n    *自连接\n\n- 外连接\n    *左外连接(左连接)\n    *右外连接(右连接)\n\n- 全连接(暂时不掌握，很少使用)\n</code></pre><p>4、当多第表进行连接查询，若没有任何条件进行限制，会发生什么现象？<br>    例：查询每一个员工所在的部门名称，要求最终显示员工名和对应部门名。</p>\n<p>mysql&gt; select deptno,ename from emp; 员工表<br>+——–+——–+<br>| deptno | ename  |<br>+——–+——–+<br>|     20 | SIMITH |<br>|     30 | ALLEN  |<br>|     30 | WARD   |<br>|     20 | JONES  |<br>|     30 | MARTIN |<br>|     30 | BLAKE  |<br>|     10 | CLARK  |<br>|     20 | SCOTT  |<br>|     10 | KING   |<br>|     30 | TURNER |<br>|     20 | ADAMS  |<br>|     30 | JAMES  |<br>|     20 | FORD   |<br>|     10 | MILLER |<br>+——–+——–+</p>\n<p>mysql&gt; select deptno,dname from dept; 部门表<br>+——–+————-+<br>| deptno | dname       |<br>+——–+————-+<br>|     10 | ACCOUNTING  |<br>|     20 | RESEARCHING |<br>|     30 | SALES       |<br>|     40 | OPERATONS   |<br>+——–+————-+</p>\n<p>主要分析：多张表连接查询，若没有任何条件限制，会发生什么？</p>\n<p>小知识： 在进行多表连接查询时，尽量给表起别名，这样效率高，可读性高。<br>mysql&gt; select e.ename,d.dname from emp e,dept d;<br>+——–+————-+<br>| ename  | dname       |<br>+——–+————-+<br>| SIMITH | ACCOUNTING  |<br>| SIMITH | RESEARCHING |<br>| SIMITH | SALES       |<br>| SIMITH | OPERATONS   |<br>| ALLEN  | ACCOUNTING  |<br>| ALLEN  | RESEARCHING |<br>| ALLEN  | SALES       |<br>| ALLEN  | OPERATONS   |<br>| WARD   | ACCOUNTING  |<br>| WARD   | RESEARCHING |<br>| WARD   | SALES       |<br>| WARD   | OPERATONS   |<br>| JONES  | ACCOUNTING  |<br>| JONES  | RESEARCHING |<br>| JONES  | SALES       |<br>| JONES  | OPERATONS   |<br>|………………… |<br>+——–+————-+<br>56 rows in set</p>\n<p>结论：若两张表进行连接查询的时候没有任何条件限制，最终的查询结果总数是两张表记录条数乘积，需要添加限制条件。</p>\n<p>例：查询每一个员工所在的部门名称，要求最终显示员工名和对应部门名。</p>\n<p>mysql&gt; select deptno,ename from emp; 员工表<br>+——–+——–+<br>| deptno | ename  |<br>+——–+——–+<br>|     20 | SIMITH |<br>|     30 | ALLEN  |<br>|     30 | WARD   |<br>|     20 | JONES  |<br>|     30 | MARTIN |<br>|     30 | BLAKE  |<br>|     10 | CLARK  |<br>|     20 | SCOTT  |<br>|     10 | KING   |<br>|     30 | TURNER |<br>|     20 | ADAMS  |<br>|     30 | JAMES  |<br>|     20 | FORD   |<br>|     10 | MILLER |<br>+——–+——–+</p>\n<p>mysql&gt; select deptno,dname from dept; 部门表<br>+——–+————-+<br>| deptno | dname       |<br>+——–+————-+<br>|     10 | ACCOUNTING  |<br>|     20 | RESEARCHING |<br>|     30 | SALES       |<br>|     40 | OPERATONS   |<br>+——–+————-+</p>\n<p>注：在连接查询的时候虽然使用了限制条件，但是匹配的次数没有减少，还是56次，只不过这一次的结果都是有效记录。</p>\n<p>SQL92语法：内连接中的等值连接<br>mysql&gt; select e.ename,d.dname from emp e,dept d where e.deptno=d.deptno;</p>\n<p>SQL99语法：内连接中的等值连接<br>mysql&gt; select e.ename,d.dname from emp e join dept d on e.deptno=d.deptno;<br>或者<br>mysql&gt; select e.ename,d.dname from emp e inner join dept d on e.deptno=d.deptno; //inner可以省略</p>\n<p>SQL99语法：表连接独立出来了，结构更清晰。对表连接不满意的话，还要以再追加where进行过滤。<br>+——–+————-+<br>| ename  | dname       |<br>+——–+————-+<br>| SIMITH | RESEARCHING |<br>| ALLEN  | SALES       |<br>| WARD   | SALES       |<br>| JONES  | RESEARCHING |<br>| MARTIN | SALES       |<br>| BLAKE  | SALES       |<br>| CLARK  | ACCOUNTING  |<br>| SCOTT  | RESEARCHING |<br>| KING   | ACCOUNTING  |<br>| TURNER | SALES       |<br>| ADAMS  | RESEARCHING |<br>| JAMES  | SALES       |<br>| FORD   | RESEARCHING |<br>| MILLER | ACCOUNTING  |<br>+——–+————-+</p>\n<p>5、例：找出每一个员工对应的工资等级，要求显示员工名，工资，工资等级</p>\n<p>SQL99语法：内连接中的非等值连接<br>mysql&gt; select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;<br>+——–+———+——-+<br>| ename  | sal     | grade |<br>+——–+———+——-+<br>| SIMITH |  800.00 |     1 |<br>| ALLEN  | 1600.00 |     3 |<br>| WARD   | 1250.00 |     2 |<br>| JONES  | 2975.00 |     4 |<br>| MARTIN | 1250.00 |     2 |<br>| BLAKE  | 2850.00 |     4 |<br>| CLARK  | 2450.00 |     4 |<br>| SCOTT  | 3000.00 |     4 |<br>| KING   | 5000.00 |     5 |<br>| TURNER | 1500.00 |     3 |<br>| ADAMS  | 1100.00 |     1 |<br>| JAMES  |  950.00 |     1 |<br>| FORD   | 3000.00 |     4 |<br>| MILLER | 1300.00 |     2 |<br>+——–+———+——-+</p>\n<p>6、找出每一个员工的上级领导，要求显示员工名以及对应的上级领导名称<br>emp a&lt;员工表&gt;<br>emp b&lt;领导表&gt;<br>条件：a.mgr=b.empno</p>\n<p>SQL99语法：内连接中的自连接<br>mysql&gt; select a.ename empname,b.ename leadername from emp a join emp b on a.mgr=b.empno;<br>+———+————+<br>| empname | leadername |<br>+———+————+<br>| SIMITH  | FORD       |<br>| ALLEN   | BLAKE      |<br>| WARD    | BLAKE      |<br>| JONES   | KING       |<br>| MARTIN  | BLAKE      |<br>| BLAKE   | KING       |<br>| CLARK   | KING       |<br>| SCOTT   | JONES      |<br>| TURNER  | BLAKE      |<br>| ADAMS   | SCOTT      |<br>| JAMES   | BLAKE      |<br>| FORD    | JONES      |<br>| MILLER  | CLARK      |<br>+———+————+</p>\n<p>7、例：找出每一个员工对应的部门名称,要求显示全部部门</p>\n<p>内连接：A表和B能够完全匹配的记录查询出来，称为内连接</p>\n<p>外连接：A表和B表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的完全查询出来，对方表没有匹配的记录，会自动模拟出NULL与之匹配，称为外连接。</p>\n<p>外连接的查询结果条数 &gt;= 内连接的查询结果条数</p>\n<p>SQL99语法：外连接中的右外连接<br>mysql&gt; select e.ename,d.dname from emp e right outter join dept d on e.deptno=d.deptno;//outer可以省略<br>mysql&gt; select e.ename,d.dname from emp e right join dept d on e.deptno=d.deptno;</p>\n<p>SQL99语法：外连接中的左外连接<br>mysql&gt; select e.ename,d.dname from dept d left outter join emp e on e.deptno=d.deptno;//outer可以省略<br>mysql&gt; select e.ename,d.dname from dept d left join emp e on e.deptno=d.deptno; </p>\n<p>注：任何一个右外连接都可以写左外连接，反之也可以</p>\n<p>+——–+————-+<br>| ename  | dname       |<br>+——–+————-+<br>| SIMITH | RESEARCHING |<br>| ALLEN  | SALES       |<br>| WARD   | SALES       |<br>| JONES  | RESEARCHING |<br>| MARTIN | SALES       |<br>| BLAKE  | SALES       |<br>| CLARK  | ACCOUNTING  |<br>| SCOTT  | RESEARCHING |<br>| KING   | ACCOUNTING  |<br>| TURNER | SALES       |<br>| ADAMS  | RESEARCHING |<br>| JAMES  | SALES       |<br>| FORD   | RESEARCHING |<br>| MILLER | ACCOUNTING  |<br>| NULL   | OPERATONS   |<br>+——–+————-+</p>\n<p>为什么inner和outter可以省略，加上去有什么好处？</p>\n<pre><code>- 可以省略，国为区分内连接和外连接依靠的不是这些关键字，而是看SQL语句中是否存在left/right，若存在，表示一定是一个外连接，其他都是内连接。\n\n- 加上去的好处是增强可读性\n</code></pre><p>8、例：找出每一个员工对应领导名，要求显示所有的员工<br>mysql&gt; select a.ename empname,b.ename leadername from emp a left join emp b on a.mgr=b.empno;<br>+———+————+<br>| empname | leadername |<br>+———+————+<br>| SIMITH  | FORD       |<br>| ALLEN   | BLAKE      |<br>| WARD    | BLAKE      |<br>| JONES   | KING       |<br>| MARTIN  | BLAKE      |<br>| BLAKE   | KING       |<br>| CLARK   | KING       |<br>| SCOTT   | JONES      |<br>| KING    | NULL       |<br>| TURNER  | BLAKE      |<br>| ADAMS   | SCOTT      |<br>| JAMES   | BLAKE      |<br>| FORD    | JONES      |<br>| MILLER  | CLARK      |<br>+———+————+</p>\n<p>9、例：找出每一个员工对应的部门名称，以及该员工对应的工资等级。要求显示员工名、部门名、工资等级。<br>mysql&gt; select e.ename,d.dname,s.grade from emp e  join dept d on e.deptno=d.deptno join salgrade s on e.sal between s.losal and s.hisal;<br>+——–+————-+——-+<br>| ename  | dname       | grade |<br>+——–+————-+——-+<br>| SIMITH | RESEARCHING |     1 |<br>| ALLEN  | SALES       |     3 |<br>| WARD   | SALES       |     2 |<br>| JONES  | RESEARCHING |     4 |<br>| MARTIN | SALES       |     2 |<br>| BLAKE  | SALES       |     4 |<br>| CLARK  | ACCOUNTING  |     4 |<br>| SCOTT  | RESEARCHING |     4 |<br>| KING   | ACCOUNTING  |     5 |<br>| TURNER | SALES       |     3 |<br>| ADAMS  | RESEARCHING |     1 |<br>| JAMES  | SALES       |     1 |<br>| FORD   | RESEARCHING |     4 |<br>| MILLER | ACCOUNTING  |     2 |<br>+——–+————-+——-+</p>\n<p>多张表进行表连接的语法格式：<br>select<br>    …<br>from<br>    a<br>join<br>    b<br>on<br>    条件<br>join<br>    c<br>on<br>    条件</p>\n<p>原理：a和b先进行表连接，接着a和c再进行表连接。</p>"},{"title":"MYSQL数据库笔记_5之子查询","date":"2018-08-10T08:18:38.000Z","_content":"\n子查询\n\n1、什么是子查询？\n\t- select 嵌套 select语句\n\n2、子查询可以出现在哪？\n\tselect ..(select)\n\tfrom ..(select)\n\twhere.. (select)\n\n<!--more-->\nwhere 后面使用子查询 \n3、例：找出薪水比公司平均薪水高的员工，要求显示员工名和薪水\n第一步：求平均薪水\nmysql> select avg(sal) asal from emp;\n+-------------+\n| asal        |\n+-------------+\n| 2073.214286 |\n+-------------+\n\n第二步:将上面的表当作临时表\nmysql> select ename,sal from emp where e.sal > (select avg(sal) from emp);\n+-------+---------+\n| ename | sal     |\n+-------+---------+\n| JONES | 2975.00 |\n| BLAKE | 2850.00 |\n| CLARK | 2450.00 |\n| SCOTT | 3000.00 |\n| KING  | 5000.00 |\n| FORD  | 3000.00 |\n+-------+---------+\n\n\n4、from面使用子查询 例：\n找出每个部门的平均薪水，并且要求显示平均薪水的薪水等级\n\n第一步：求部门平均薪水\nmysql> select deptno,avg(sal) asal from emp group by deptno;\n+--------+-------------+\n| deptno | asal        |\n+--------+-------------+\n|     10 | 2916.666667 |\n|     20 | 2175.000000 |\n|     30 | 1566.666667 |\n+--------+-------------+\n\n第二步：将上面的表当作临时表\nmysql> select t.deptno,t.asal,s.grade from (select deptno,avg(sal) asal from emp group by deptno) t join salgrade s on t.asal between s.losal and s.hisal;\n+--------+-------------+-------+\n| deptno | asal        | grade |\n+--------+-------------+-------+\n|     10 | 2916.666667 |     4 |\n|     20 | 2175.000000 |     4 |\n|     30 | 1566.666667 |     3 |\n+--------+-------------+-------+\n\n\n5、select后面使用子查询[了解]\n\n\n\n6、union 将两条语句联合 [了解]\nselect ename,job from emp where job='manger'\nunion\nselect ename,job from emp where job='salesman'\n","source":"_posts/MYSQL数据库笔记-5之子查询.md","raw":"---\ntitle: MYSQL数据库笔记_5之子查询\ndate: 2018-08-10 16:18:38\ntags:\n---\n\n子查询\n\n1、什么是子查询？\n\t- select 嵌套 select语句\n\n2、子查询可以出现在哪？\n\tselect ..(select)\n\tfrom ..(select)\n\twhere.. (select)\n\n<!--more-->\nwhere 后面使用子查询 \n3、例：找出薪水比公司平均薪水高的员工，要求显示员工名和薪水\n第一步：求平均薪水\nmysql> select avg(sal) asal from emp;\n+-------------+\n| asal        |\n+-------------+\n| 2073.214286 |\n+-------------+\n\n第二步:将上面的表当作临时表\nmysql> select ename,sal from emp where e.sal > (select avg(sal) from emp);\n+-------+---------+\n| ename | sal     |\n+-------+---------+\n| JONES | 2975.00 |\n| BLAKE | 2850.00 |\n| CLARK | 2450.00 |\n| SCOTT | 3000.00 |\n| KING  | 5000.00 |\n| FORD  | 3000.00 |\n+-------+---------+\n\n\n4、from面使用子查询 例：\n找出每个部门的平均薪水，并且要求显示平均薪水的薪水等级\n\n第一步：求部门平均薪水\nmysql> select deptno,avg(sal) asal from emp group by deptno;\n+--------+-------------+\n| deptno | asal        |\n+--------+-------------+\n|     10 | 2916.666667 |\n|     20 | 2175.000000 |\n|     30 | 1566.666667 |\n+--------+-------------+\n\n第二步：将上面的表当作临时表\nmysql> select t.deptno,t.asal,s.grade from (select deptno,avg(sal) asal from emp group by deptno) t join salgrade s on t.asal between s.losal and s.hisal;\n+--------+-------------+-------+\n| deptno | asal        | grade |\n+--------+-------------+-------+\n|     10 | 2916.666667 |     4 |\n|     20 | 2175.000000 |     4 |\n|     30 | 1566.666667 |     3 |\n+--------+-------------+-------+\n\n\n5、select后面使用子查询[了解]\n\n\n\n6、union 将两条语句联合 [了解]\nselect ename,job from emp where job='manger'\nunion\nselect ename,job from emp where job='salesman'\n","slug":"MYSQL数据库笔记-5之子查询","published":1,"updated":"2018-09-13T12:41:24.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm0r966f0004mlfikm9ughos","content":"<p>子查询</p>\n<p>1、什么是子查询？</p>\n<pre><code>- select 嵌套 select语句\n</code></pre><p>2、子查询可以出现在哪？<br>    select ..(select)<br>    from ..(select)<br>    where.. (select)</p>\n<a id=\"more\"></a>\n<p>where 后面使用子查询<br>3、例：找出薪水比公司平均薪水高的员工，要求显示员工名和薪水<br>第一步：求平均薪水<br>mysql&gt; select avg(sal) asal from emp;<br>+————-+<br>| asal        |<br>+————-+<br>| 2073.214286 |<br>+————-+</p>\n<p>第二步:将上面的表当作临时表<br>mysql&gt; select ename,sal from emp where e.sal &gt; (select avg(sal) from emp);<br>+——-+———+<br>| ename | sal     |<br>+——-+———+<br>| JONES | 2975.00 |<br>| BLAKE | 2850.00 |<br>| CLARK | 2450.00 |<br>| SCOTT | 3000.00 |<br>| KING  | 5000.00 |<br>| FORD  | 3000.00 |<br>+——-+———+</p>\n<p>4、from面使用子查询 例：<br>找出每个部门的平均薪水，并且要求显示平均薪水的薪水等级</p>\n<p>第一步：求部门平均薪水<br>mysql&gt; select deptno,avg(sal) asal from emp group by deptno;<br>+——–+————-+<br>| deptno | asal        |<br>+——–+————-+<br>|     10 | 2916.666667 |<br>|     20 | 2175.000000 |<br>|     30 | 1566.666667 |<br>+——–+————-+</p>\n<p>第二步：将上面的表当作临时表<br>mysql&gt; select t.deptno,t.asal,s.grade from (select deptno,avg(sal) asal from emp group by deptno) t join salgrade s on t.asal between s.losal and s.hisal;<br>+——–+————-+——-+<br>| deptno | asal        | grade |<br>+——–+————-+——-+<br>|     10 | 2916.666667 |     4 |<br>|     20 | 2175.000000 |     4 |<br>|     30 | 1566.666667 |     3 |<br>+——–+————-+——-+</p>\n<p>5、select后面使用子查询[了解]</p>\n<p>6、union 将两条语句联合 [了解]<br>select ename,job from emp where job=’manger’<br>union<br>select ename,job from emp where job=’salesman’</p>\n","site":{"data":{}},"excerpt":"<p>子查询</p>\n<p>1、什么是子查询？</p>\n<pre><code>- select 嵌套 select语句\n</code></pre><p>2、子查询可以出现在哪？<br>    select ..(select)<br>    from ..(select)<br>    where.. (select)</p>","more":"<p>where 后面使用子查询<br>3、例：找出薪水比公司平均薪水高的员工，要求显示员工名和薪水<br>第一步：求平均薪水<br>mysql&gt; select avg(sal) asal from emp;<br>+————-+<br>| asal        |<br>+————-+<br>| 2073.214286 |<br>+————-+</p>\n<p>第二步:将上面的表当作临时表<br>mysql&gt; select ename,sal from emp where e.sal &gt; (select avg(sal) from emp);<br>+——-+———+<br>| ename | sal     |<br>+——-+———+<br>| JONES | 2975.00 |<br>| BLAKE | 2850.00 |<br>| CLARK | 2450.00 |<br>| SCOTT | 3000.00 |<br>| KING  | 5000.00 |<br>| FORD  | 3000.00 |<br>+——-+———+</p>\n<p>4、from面使用子查询 例：<br>找出每个部门的平均薪水，并且要求显示平均薪水的薪水等级</p>\n<p>第一步：求部门平均薪水<br>mysql&gt; select deptno,avg(sal) asal from emp group by deptno;<br>+——–+————-+<br>| deptno | asal        |<br>+——–+————-+<br>|     10 | 2916.666667 |<br>|     20 | 2175.000000 |<br>|     30 | 1566.666667 |<br>+——–+————-+</p>\n<p>第二步：将上面的表当作临时表<br>mysql&gt; select t.deptno,t.asal,s.grade from (select deptno,avg(sal) asal from emp group by deptno) t join salgrade s on t.asal between s.losal and s.hisal;<br>+——–+————-+——-+<br>| deptno | asal        | grade |<br>+——–+————-+——-+<br>|     10 | 2916.666667 |     4 |<br>|     20 | 2175.000000 |     4 |<br>|     30 | 1566.666667 |     3 |<br>+——–+————-+——-+</p>\n<p>5、select后面使用子查询[了解]</p>\n<p>6、union 将两条语句联合 [了解]<br>select ename,job from emp where job=’manger’<br>union<br>select ename,job from emp where job=’salesman’</p>"},{"title":"MYSQL数据库笔记_6之limit","date":"2018-08-10T08:19:42.000Z","_content":"\nlimit\n\n1、limit用来获取一张表中的某部分数据\n\n2、limit只有在MYSQL中存在，不通用。\n<!--more-->\n3、例：找出员工表中前5条记录\nmysql> select ename from emp limit 5;\n+--------+\n| ename  |\n+--------+\n| SIMITH |\n| ALLEN  |\n| WARD   |\n| JONES  |\n| MARTIN |\n+--------+\n\n以上SQL语句的‘limit 5’中的表示从表中记录下标0开始，取5条\n等同于下条语句：\nselect ename from emp limit 0,5;\n\nlimit语法格式 ：\n\tlimit 起始下标，长度\n\t起始下标没有指定，默认从0开始，0表示表中第一条记录\n\tlimit 出现在SQL语句最后面；\n\n4、例：找出工资排名前5名的员工\nmysql> select ename,sal from emp order by sal desc limit 5;\n+-------+---------+\n| ename | sal     |\n+-------+---------+\n| KING  | 5000.00 |\n| FORD  | 3000.00 |\n| SCOTT | 3000.00 |\n| JONES | 2975.00 |\n| BLAKE | 2850.00 |\n+-------+---------+\n\n5、例：找出工资排名在 (3-9)名的员工：\nmysql> select ename,sal from emp order by sal desc limit 2,7;\n+--------+---------+\n| ename  | sal     |\n+--------+---------+\n| SCOTT  | 3000.00 |\n| JONES  | 2975.00 |\n| BLAKE  | 2850.00 |\n| CLARK  | 2450.00 |\n| ALLEN  | 1600.00 |\n| TURNER | 1500.00 |\n| MILLER | 1300.00 |\n+--------+---------+\n\n6、MYSQL中分页语句：\n\n每页显示3条记录：\n第1页：0,3\n第2页：3,3\n第3页：6,3\n第4页：9,3\n\n每页显示pageSize条记录\n第pageNo页：(pageNo - 1) × pageSize，pageSize\n\nselect \n\ta\nfrom\n\tb\norder by\n\t* desc\nlimit\n\t(pageNo - 1) × pageSize，pageSize;\n","source":"_posts/MYSQL数据库笔记-6之limit.md","raw":"---\ntitle: MYSQL数据库笔记_6之limit\ndate: 2018-08-10 16:19:42\ntags:\n---\n\nlimit\n\n1、limit用来获取一张表中的某部分数据\n\n2、limit只有在MYSQL中存在，不通用。\n<!--more-->\n3、例：找出员工表中前5条记录\nmysql> select ename from emp limit 5;\n+--------+\n| ename  |\n+--------+\n| SIMITH |\n| ALLEN  |\n| WARD   |\n| JONES  |\n| MARTIN |\n+--------+\n\n以上SQL语句的‘limit 5’中的表示从表中记录下标0开始，取5条\n等同于下条语句：\nselect ename from emp limit 0,5;\n\nlimit语法格式 ：\n\tlimit 起始下标，长度\n\t起始下标没有指定，默认从0开始，0表示表中第一条记录\n\tlimit 出现在SQL语句最后面；\n\n4、例：找出工资排名前5名的员工\nmysql> select ename,sal from emp order by sal desc limit 5;\n+-------+---------+\n| ename | sal     |\n+-------+---------+\n| KING  | 5000.00 |\n| FORD  | 3000.00 |\n| SCOTT | 3000.00 |\n| JONES | 2975.00 |\n| BLAKE | 2850.00 |\n+-------+---------+\n\n5、例：找出工资排名在 (3-9)名的员工：\nmysql> select ename,sal from emp order by sal desc limit 2,7;\n+--------+---------+\n| ename  | sal     |\n+--------+---------+\n| SCOTT  | 3000.00 |\n| JONES  | 2975.00 |\n| BLAKE  | 2850.00 |\n| CLARK  | 2450.00 |\n| ALLEN  | 1600.00 |\n| TURNER | 1500.00 |\n| MILLER | 1300.00 |\n+--------+---------+\n\n6、MYSQL中分页语句：\n\n每页显示3条记录：\n第1页：0,3\n第2页：3,3\n第3页：6,3\n第4页：9,3\n\n每页显示pageSize条记录\n第pageNo页：(pageNo - 1) × pageSize，pageSize\n\nselect \n\ta\nfrom\n\tb\norder by\n\t* desc\nlimit\n\t(pageNo - 1) × pageSize，pageSize;\n","slug":"MYSQL数据库笔记-6之limit","published":1,"updated":"2018-09-13T12:41:24.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm0r966h0005mlfi6e5k4g3a","content":"<p>limit</p>\n<p>1、limit用来获取一张表中的某部分数据</p>\n<p>2、limit只有在MYSQL中存在，不通用。<br><a id=\"more\"></a><br>3、例：找出员工表中前5条记录<br>mysql&gt; select ename from emp limit 5;<br>+——–+<br>| ename  |<br>+——–+<br>| SIMITH |<br>| ALLEN  |<br>| WARD   |<br>| JONES  |<br>| MARTIN |<br>+——–+</p>\n<p>以上SQL语句的‘limit 5’中的表示从表中记录下标0开始，取5条<br>等同于下条语句：<br>select ename from emp limit 0,5;</p>\n<p>limit语法格式 ：<br>    limit 起始下标，长度<br>    起始下标没有指定，默认从0开始，0表示表中第一条记录<br>    limit 出现在SQL语句最后面；</p>\n<p>4、例：找出工资排名前5名的员工<br>mysql&gt; select ename,sal from emp order by sal desc limit 5;<br>+——-+———+<br>| ename | sal     |<br>+——-+———+<br>| KING  | 5000.00 |<br>| FORD  | 3000.00 |<br>| SCOTT | 3000.00 |<br>| JONES | 2975.00 |<br>| BLAKE | 2850.00 |<br>+——-+———+</p>\n<p>5、例：找出工资排名在 (3-9)名的员工：<br>mysql&gt; select ename,sal from emp order by sal desc limit 2,7;<br>+——–+———+<br>| ename  | sal     |<br>+——–+———+<br>| SCOTT  | 3000.00 |<br>| JONES  | 2975.00 |<br>| BLAKE  | 2850.00 |<br>| CLARK  | 2450.00 |<br>| ALLEN  | 1600.00 |<br>| TURNER | 1500.00 |<br>| MILLER | 1300.00 |<br>+——–+———+</p>\n<p>6、MYSQL中分页语句：</p>\n<p>每页显示3条记录：<br>第1页：0,3<br>第2页：3,3<br>第3页：6,3<br>第4页：9,3</p>\n<p>每页显示pageSize条记录<br>第pageNo页：(pageNo - 1) × pageSize，pageSize</p>\n<p>select<br>    a<br>from<br>    b<br>order by</p>\n<pre><code>* desc\n</code></pre><p>limit<br>    (pageNo - 1) × pageSize，pageSize;</p>\n","site":{"data":{}},"excerpt":"<p>limit</p>\n<p>1、limit用来获取一张表中的某部分数据</p>\n<p>2、limit只有在MYSQL中存在，不通用。<br>","more":"<br>3、例：找出员工表中前5条记录<br>mysql&gt; select ename from emp limit 5;<br>+——–+<br>| ename  |<br>+——–+<br>| SIMITH |<br>| ALLEN  |<br>| WARD   |<br>| JONES  |<br>| MARTIN |<br>+——–+</p>\n<p>以上SQL语句的‘limit 5’中的表示从表中记录下标0开始，取5条<br>等同于下条语句：<br>select ename from emp limit 0,5;</p>\n<p>limit语法格式 ：<br>    limit 起始下标，长度<br>    起始下标没有指定，默认从0开始，0表示表中第一条记录<br>    limit 出现在SQL语句最后面；</p>\n<p>4、例：找出工资排名前5名的员工<br>mysql&gt; select ename,sal from emp order by sal desc limit 5;<br>+——-+———+<br>| ename | sal     |<br>+——-+———+<br>| KING  | 5000.00 |<br>| FORD  | 3000.00 |<br>| SCOTT | 3000.00 |<br>| JONES | 2975.00 |<br>| BLAKE | 2850.00 |<br>+——-+———+</p>\n<p>5、例：找出工资排名在 (3-9)名的员工：<br>mysql&gt; select ename,sal from emp order by sal desc limit 2,7;<br>+——–+———+<br>| ename  | sal     |<br>+——–+———+<br>| SCOTT  | 3000.00 |<br>| JONES  | 2975.00 |<br>| BLAKE  | 2850.00 |<br>| CLARK  | 2450.00 |<br>| ALLEN  | 1600.00 |<br>| TURNER | 1500.00 |<br>| MILLER | 1300.00 |<br>+——–+———+</p>\n<p>6、MYSQL中分页语句：</p>\n<p>每页显示3条记录：<br>第1页：0,3<br>第2页：3,3<br>第3页：6,3<br>第4页：9,3</p>\n<p>每页显示pageSize条记录<br>第pageNo页：(pageNo - 1) × pageSize，pageSize</p>\n<p>select<br>    a<br>from<br>    b<br>order by</p>\n<pre><code>* desc\n</code></pre><p>limit<br>    (pageNo - 1) × pageSize，pageSize;</p>"},{"title":"MYSQL数据库笔记_7之表的创建","date":"2018-08-10T08:20:24.000Z","_content":"表\n\n1、表格，用来存储数据，表格是一种结构化文件\n\n2、表格行被 称为记录（表中的数据），表格列被称为字段。\n\n3、字段的属性：字段名称、字段数据类型、字段长度、字段约束\n\n<!--more-->\n4、创建表的语法：\n\tcreate table tablename(\n\t\tcolunmnamedatatype(length),\n\t\tcolunmnamedatatype(length),\n\t\tcolunmnamedatatype(length),\n\t\tcolunmnamedatatype(length),\n\t\tcolunmnamedatatype(length)\n\t);\n\n5、关于MYSQL数据库中的类型：\n\t- varchar\n\t\t可变长度字符串\n\t\tvarchar（3）表示存储字符串长度不能超过3\n\t- char\n\t\t定长字符串\n\t\tchar（3）表示存储字符串长度不能超过3\n\t\n\tvarchar和char对比：\n\t\t\t- 都是字符串类型\n\t\t\t- varchar比较智能，可能根据实际的数据长度分配空间，比较节省空间，但是在分配的时候需要执行相关的判断程序，效率较低。\n\t\t\t- char不需要动态分配空间，所以执行效率很高，但是可能会导致空间浪费。\n\t\t\t- 若字段中的数据不具备伸缩性，建议采用char类型存储。\n\t\t\t- 若字段中的数据具备很强伸缩性，建议采用varchar类型存储。\n\n\t- int\n\t\t整型\n\t\tint（3）表示最大可以存储999\n\t- bigint\n\t\t长整型\n\t- float\n\t\t浮点型单精度\n\t\tfloat（7,2）7表示7个有效数字，2表示小数位\n\t- double\n\t\t浮点型双精度\n\t- date\n\t\t日期类型\n\t\t在实际开发中为了通用，所以日期类型一般不用，采用字符器串代替日期比较多。\n\t- blob\n\t\tbinary large object 二进制大对象\n\t\t专门存储图片声音视频等数据\n\t\t数据库中存储一个图片是很见的，但是存储一个较大的视频是很少的，一般都 是提供一个视频的的链接地址。\n\t- clob\n\t\tcharactor large object 字符大对象\n\t\t可以存储一个比较大的文本，4G +的字符串\n\t- 其它。。。\n\n\n6、创建表格（学生表）\n\t建立学生信息表，字段包括：学号、姓名、性别、出生日期、eamil\n\ncreate table t_student(\n\tid int(10),\n\tname varchar(32),\n\tsex char(1),\n\tbirth date,\n\temail varchar(128)\n);\n\n\t注：表格的名字是好以t_或tbl开头，增强可读性\n\t\tvarchar长度最好是2的倍数，方便存储中文\n\n删除表格：\n\tdrop table t_student;这种删除方式，若数据库没有这样的表格，报错\n\tdrop table if exists t_student;最好采用这种方式，只有MYSQL才能用\n\n7、向t_student表格中插入数据\n\t7.1语法格式：\n\t\tinsert into tablename(columnname1,columnname2..) values(value1,value2...)\n\t\t字段和值必须一一对应，个数必须相同，数据类型必须一致\n\t7.2 向t_student插入数据\n\t\tinsert into t_student(id,name,sex,birth,email) values(1,'zhangsan','m','1987-09-17','zhangsan@qq.com');\n\n\t\tinsert into t_student(id,name,sex,birth,email) values(2,'lisi','f','1987-09-27','lisi@qq.com');\n\n\t\tmysql> select * from t_student;\n\t\t+------+----------+------+------------+-----------------+\n\t\t| id   | name     | sex  | birth      | email           |\n\t\t+------+----------+------+------------+-----------------+\n\t\t|    1 | zhangsan | m    | 1987-09-17 | zhangsan@qq.com |\n\t\t|    2 | lisi     | f    | 1987-09-27 | lisi@qq.com     |\n\t\t+------+----------+------+------------+-----------------+\n\n\t\tinsert into t_student(id,name) values(3,'wangwu');\n\t\tmysql> select * from t_student;\n\t\t+------+----------+------+------------+-----------------+\n\t\t| id   | name     | sex  | birth      | email           |\n\t\t+------+----------+------+------------+-----------------+\n\t\t|    1 | zhangsan | m    | 1987-09-17 | zhangsan@qq.com |\n\t\t|    2 | lisi     | f    | 1987-09-27 | lisi@qq.com     |\n\t\t|    3 | wangwu   | NULL | NULL       | NULL            |\n\t\t+------+----------+------+------------+-----------------+\n\t\t\n\t\t当一张表没有指定约束的话，可以为null值\n\n\t\t可以向sex、birth、eamil插入值吗？\n\t\tupdate语句进行更新数据操作\n\t\tupdate t_student set sex='m',birth='1999-02-10',email='wangwu@qq.com' where id=3;\n\n\t\tmysql> select * from t_student;\n\t\t+------+----------+------+------------+-----------------+\n\t\t| id   | name     | sex  | birth      | email           |\n\t\t+------+----------+------+------------+-----------------+\n\t\t|    1 | zhangsan | m    | 1987-09-17 | zhangsan@qq.com |\n\t\t|    2 | lisi     | f    | 1987-09-27 | lisi@qq.com     |\n\t\t|    3 | wangwu   | m    | 1999-02-10 | wangwu@qq.com   |\n\t\t+------+----------+------+------------+-----------------+\n\n关于SQL脚本：\n\t你是怎么看SQL脚本的？\n\t-该文件是一个普通的文本文件，后缀名.sql,称为SQL脚本\n\t- 在SQL脚本中有大量的SQL语句，想指执行SQL语句，可以将这些SQL语句写入SQL脚本中，直接使用source执行脚本。\n\tsource 脚本文件路径\n\n9、获取系统当前时间：\n\tnow()获取当前时间\n\tmysql> select now();\n\t+---------------------+\n\t| now()               |\n\t+---------------------+\n\t| 2018-08-10 11:45:09 |\n\t+---------------------+\n\n\t创建表，机构表：\ncreate table t_organization(\n\tcode char(10),\n\tname varchar(32),\n\tcreatetime date\n);\n\ninsert into t_organization(code,name,createtime) values('111111','国家外汇局',now());\ninsert into t_organization(code,name,createtime) values('111112','北京市外汇局',now());\ninsert into t_organization(code,name,createtime) values('111113','海南省外汇局',now());\ninsert into t_organization(code,name,createtime) values('111114','山东省外汇局',now());\ninsert into t_organization(code,name,createtime) values('111115','福建省外汇局',now());\n\n\n10、表的复制[快速创建表格]\n语法：create table tablename1 as select columnname1,columnname2,...from tablename2;\n\t\nmysql> create table emp1 as select ename,job,sal from emp;\n+--------+-----------+---------+\n| ename  | job       | sal     |\n+--------+-----------+---------+\n| SIMITH | CLERK     |  800.00 |\n| ALLEN  | SALESMAN  | 1600.00 |\n| WARD   | SALESMAN  | 1250.00 |\n| JONES  | MANAGER   | 2975.00 |\n| MARTIN | SALESMAN  | 1250.00 |\n| BLAKE  | MANAGER   | 2850.00 |\n| CLARK  | MANAGER   | 2450.00 |\n| SCOTT  | ANALYST   | 3000.00 |\n| KING   | PRESIDENT | 5000.00 |\n| TURNER | SALESMAN  | 1500.00 |\n| ADAMS  | CLERK     | 1100.00 |\n| JAMES  | CLERK     |  950.00 |\n| FORD   | ANALYST   | 3000.00 |\n| MILLER | CLERK     | 1300.00 |\n+--------+-----------+---------+\n\n11、将查询结果插入某张表中\nmysql> insert into emp1 select * from emp1 where sal=3000;\n\nmysql> select * from emp1;\n+--------+-----------+---------+\n| ename  | job       | sal     |\n+--------+-----------+---------+\n| SIMITH | CLERK     |  800.00 |\n| ALLEN  | SALESMAN  | 1600.00 |\n| WARD   | SALESMAN  | 1250.00 |\n| JONES  | MANAGER   | 2975.00 |\n| MARTIN | SALESMAN  | 1250.00 |\n| BLAKE  | MANAGER   | 2850.00 |\n| CLARK  | MANAGER   | 2450.00 |\n| SCOTT  | ANALYST   | 3000.00 |\n| KING   | PRESIDENT | 5000.00 |\n| TURNER | SALESMAN  | 1500.00 |\n| ADAMS  | CLERK     | 1100.00 |\n| JAMES  | CLERK     |  950.00 |\n| FORD   | ANALYST   | 3000.00 |\n| MILLER | CLERK     | 1300.00 |\n| SCOTT  | ANALYST   | 3000.00 |\n| FORD   | ANALYST   | 3000.00 |\n+--------+-----------+---------+\n\n\n12、增/删/改 表结构\n\ndrop table if exists t_student;\ncreate table t_student(\n\tid int(10),\n\tname varchar(32)\n);\n\nmysql> desc t_student;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| id    | int(10)     | YES  |     | NULL    |       |\n| name  | varchar(32) | YES  |     | NULL    |       |\n+-------+-------------+------+-----+---------+-------+\n\n*给t_student表格添加一个联系电话字段\nalter table t_student add phone char(11) not null default '';\n\nmysql> desc t_student;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| id    | int(10)     | YES  |     | NULL    |       |\n| name  | varchar(32) | YES  |     | NULL    |       |\n| phone | char(11)    | NO   |     |         |       |\n+-------+-------------+------+-----+---------+-------+\n\n\n*将t_student字段的类型和长度修改下\n\n语法：alter table 表名 modify 列名 新的类型名 新列参数;\n\nalter table t_student modify phone varchar(20);\nmysql> desc t_student;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| id    | int(10)     | YES  |     | NULL    |       |\n| name  | varchar(32) | YES  |     | NULL    |       |\n| phone | varchar(20) | YES  |     | NULL    |       |\n+-------+-------------+------+-----+---------+-------+\n\n\n*将t_student字段的名称、类型和长度修改下\n\n语法：alter table 表名 change 旧列名 新列名 新类型 新参数;\n\nalter table t_student change phone telphone varchar(26);\nmysql> desc t_student;\n+----------+-------------+------+-----+---------+-------+\n| Field    | Type        | Null | Key | Default | Extra |\n+----------+-------------+------+-----+---------+-------+\n| id       | int(10)     | YES  |     | NULL    |       |\n| name     | varchar(32) | YES  |     | NULL    |       |\n| telphone | varchar(26) | YES  |     | NULL    |       |\n+----------+-------------+------+-----+---------+-------+\n\n\n*将t_student表格中的telphone字段删除\nalter table t_student drop telphone;\nmysql> desc t_student;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| id    | int(10)     | YES  |     | NULL    |       |\n| name  | varchar(32) | YES  |     | NULL    |       |\n+-------+-------------+------+-----+---------+-------+\n\n13、增/删/改表结构[insert,delete,,update]\n\n\t13.1 update 语法格式：\n\t\tupdate tablename set 字段名1=字段值，字段名2=字段值2 ..where 条件;\n\n\t\t注：update语句没有条件限制，会将一张表中全部数据更新\n\t\tmysql> select * from t_student;\n\t\t+------+------+\n\t\t| id   | name |\n\t\t+------+------+\n\t\t|    1 | NULL |\n\t\t|    2 | NULL |\n\t\t+------+------+\n\n\t\t将id=2的name改为lisi\n\t\tupdate t_student set name='lisi' where id=2;\n\t\tmysql> select * from t_student;\n\t\t+------+------+\n\t\t| id   | name |\n\t\t+------+------+\n\t\t|    1 | NULL |\n\t\t|    2 | lisi |\n\t\t+------+------+\n\n\t13.2 delete\n\t格式：delete from tablename 条件\n\t注：若没条件限制，会将表中记录全部删除\n","source":"_posts/MYSQL数据库笔记-7之表的创建.md","raw":"---\ntitle: MYSQL数据库笔记_7之表的创建\ndate: 2018-08-10 16:20:24\ntags:\n---\n表\n\n1、表格，用来存储数据，表格是一种结构化文件\n\n2、表格行被 称为记录（表中的数据），表格列被称为字段。\n\n3、字段的属性：字段名称、字段数据类型、字段长度、字段约束\n\n<!--more-->\n4、创建表的语法：\n\tcreate table tablename(\n\t\tcolunmnamedatatype(length),\n\t\tcolunmnamedatatype(length),\n\t\tcolunmnamedatatype(length),\n\t\tcolunmnamedatatype(length),\n\t\tcolunmnamedatatype(length)\n\t);\n\n5、关于MYSQL数据库中的类型：\n\t- varchar\n\t\t可变长度字符串\n\t\tvarchar（3）表示存储字符串长度不能超过3\n\t- char\n\t\t定长字符串\n\t\tchar（3）表示存储字符串长度不能超过3\n\t\n\tvarchar和char对比：\n\t\t\t- 都是字符串类型\n\t\t\t- varchar比较智能，可能根据实际的数据长度分配空间，比较节省空间，但是在分配的时候需要执行相关的判断程序，效率较低。\n\t\t\t- char不需要动态分配空间，所以执行效率很高，但是可能会导致空间浪费。\n\t\t\t- 若字段中的数据不具备伸缩性，建议采用char类型存储。\n\t\t\t- 若字段中的数据具备很强伸缩性，建议采用varchar类型存储。\n\n\t- int\n\t\t整型\n\t\tint（3）表示最大可以存储999\n\t- bigint\n\t\t长整型\n\t- float\n\t\t浮点型单精度\n\t\tfloat（7,2）7表示7个有效数字，2表示小数位\n\t- double\n\t\t浮点型双精度\n\t- date\n\t\t日期类型\n\t\t在实际开发中为了通用，所以日期类型一般不用，采用字符器串代替日期比较多。\n\t- blob\n\t\tbinary large object 二进制大对象\n\t\t专门存储图片声音视频等数据\n\t\t数据库中存储一个图片是很见的，但是存储一个较大的视频是很少的，一般都 是提供一个视频的的链接地址。\n\t- clob\n\t\tcharactor large object 字符大对象\n\t\t可以存储一个比较大的文本，4G +的字符串\n\t- 其它。。。\n\n\n6、创建表格（学生表）\n\t建立学生信息表，字段包括：学号、姓名、性别、出生日期、eamil\n\ncreate table t_student(\n\tid int(10),\n\tname varchar(32),\n\tsex char(1),\n\tbirth date,\n\temail varchar(128)\n);\n\n\t注：表格的名字是好以t_或tbl开头，增强可读性\n\t\tvarchar长度最好是2的倍数，方便存储中文\n\n删除表格：\n\tdrop table t_student;这种删除方式，若数据库没有这样的表格，报错\n\tdrop table if exists t_student;最好采用这种方式，只有MYSQL才能用\n\n7、向t_student表格中插入数据\n\t7.1语法格式：\n\t\tinsert into tablename(columnname1,columnname2..) values(value1,value2...)\n\t\t字段和值必须一一对应，个数必须相同，数据类型必须一致\n\t7.2 向t_student插入数据\n\t\tinsert into t_student(id,name,sex,birth,email) values(1,'zhangsan','m','1987-09-17','zhangsan@qq.com');\n\n\t\tinsert into t_student(id,name,sex,birth,email) values(2,'lisi','f','1987-09-27','lisi@qq.com');\n\n\t\tmysql> select * from t_student;\n\t\t+------+----------+------+------------+-----------------+\n\t\t| id   | name     | sex  | birth      | email           |\n\t\t+------+----------+------+------------+-----------------+\n\t\t|    1 | zhangsan | m    | 1987-09-17 | zhangsan@qq.com |\n\t\t|    2 | lisi     | f    | 1987-09-27 | lisi@qq.com     |\n\t\t+------+----------+------+------------+-----------------+\n\n\t\tinsert into t_student(id,name) values(3,'wangwu');\n\t\tmysql> select * from t_student;\n\t\t+------+----------+------+------------+-----------------+\n\t\t| id   | name     | sex  | birth      | email           |\n\t\t+------+----------+------+------------+-----------------+\n\t\t|    1 | zhangsan | m    | 1987-09-17 | zhangsan@qq.com |\n\t\t|    2 | lisi     | f    | 1987-09-27 | lisi@qq.com     |\n\t\t|    3 | wangwu   | NULL | NULL       | NULL            |\n\t\t+------+----------+------+------------+-----------------+\n\t\t\n\t\t当一张表没有指定约束的话，可以为null值\n\n\t\t可以向sex、birth、eamil插入值吗？\n\t\tupdate语句进行更新数据操作\n\t\tupdate t_student set sex='m',birth='1999-02-10',email='wangwu@qq.com' where id=3;\n\n\t\tmysql> select * from t_student;\n\t\t+------+----------+------+------------+-----------------+\n\t\t| id   | name     | sex  | birth      | email           |\n\t\t+------+----------+------+------------+-----------------+\n\t\t|    1 | zhangsan | m    | 1987-09-17 | zhangsan@qq.com |\n\t\t|    2 | lisi     | f    | 1987-09-27 | lisi@qq.com     |\n\t\t|    3 | wangwu   | m    | 1999-02-10 | wangwu@qq.com   |\n\t\t+------+----------+------+------------+-----------------+\n\n关于SQL脚本：\n\t你是怎么看SQL脚本的？\n\t-该文件是一个普通的文本文件，后缀名.sql,称为SQL脚本\n\t- 在SQL脚本中有大量的SQL语句，想指执行SQL语句，可以将这些SQL语句写入SQL脚本中，直接使用source执行脚本。\n\tsource 脚本文件路径\n\n9、获取系统当前时间：\n\tnow()获取当前时间\n\tmysql> select now();\n\t+---------------------+\n\t| now()               |\n\t+---------------------+\n\t| 2018-08-10 11:45:09 |\n\t+---------------------+\n\n\t创建表，机构表：\ncreate table t_organization(\n\tcode char(10),\n\tname varchar(32),\n\tcreatetime date\n);\n\ninsert into t_organization(code,name,createtime) values('111111','国家外汇局',now());\ninsert into t_organization(code,name,createtime) values('111112','北京市外汇局',now());\ninsert into t_organization(code,name,createtime) values('111113','海南省外汇局',now());\ninsert into t_organization(code,name,createtime) values('111114','山东省外汇局',now());\ninsert into t_organization(code,name,createtime) values('111115','福建省外汇局',now());\n\n\n10、表的复制[快速创建表格]\n语法：create table tablename1 as select columnname1,columnname2,...from tablename2;\n\t\nmysql> create table emp1 as select ename,job,sal from emp;\n+--------+-----------+---------+\n| ename  | job       | sal     |\n+--------+-----------+---------+\n| SIMITH | CLERK     |  800.00 |\n| ALLEN  | SALESMAN  | 1600.00 |\n| WARD   | SALESMAN  | 1250.00 |\n| JONES  | MANAGER   | 2975.00 |\n| MARTIN | SALESMAN  | 1250.00 |\n| BLAKE  | MANAGER   | 2850.00 |\n| CLARK  | MANAGER   | 2450.00 |\n| SCOTT  | ANALYST   | 3000.00 |\n| KING   | PRESIDENT | 5000.00 |\n| TURNER | SALESMAN  | 1500.00 |\n| ADAMS  | CLERK     | 1100.00 |\n| JAMES  | CLERK     |  950.00 |\n| FORD   | ANALYST   | 3000.00 |\n| MILLER | CLERK     | 1300.00 |\n+--------+-----------+---------+\n\n11、将查询结果插入某张表中\nmysql> insert into emp1 select * from emp1 where sal=3000;\n\nmysql> select * from emp1;\n+--------+-----------+---------+\n| ename  | job       | sal     |\n+--------+-----------+---------+\n| SIMITH | CLERK     |  800.00 |\n| ALLEN  | SALESMAN  | 1600.00 |\n| WARD   | SALESMAN  | 1250.00 |\n| JONES  | MANAGER   | 2975.00 |\n| MARTIN | SALESMAN  | 1250.00 |\n| BLAKE  | MANAGER   | 2850.00 |\n| CLARK  | MANAGER   | 2450.00 |\n| SCOTT  | ANALYST   | 3000.00 |\n| KING   | PRESIDENT | 5000.00 |\n| TURNER | SALESMAN  | 1500.00 |\n| ADAMS  | CLERK     | 1100.00 |\n| JAMES  | CLERK     |  950.00 |\n| FORD   | ANALYST   | 3000.00 |\n| MILLER | CLERK     | 1300.00 |\n| SCOTT  | ANALYST   | 3000.00 |\n| FORD   | ANALYST   | 3000.00 |\n+--------+-----------+---------+\n\n\n12、增/删/改 表结构\n\ndrop table if exists t_student;\ncreate table t_student(\n\tid int(10),\n\tname varchar(32)\n);\n\nmysql> desc t_student;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| id    | int(10)     | YES  |     | NULL    |       |\n| name  | varchar(32) | YES  |     | NULL    |       |\n+-------+-------------+------+-----+---------+-------+\n\n*给t_student表格添加一个联系电话字段\nalter table t_student add phone char(11) not null default '';\n\nmysql> desc t_student;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| id    | int(10)     | YES  |     | NULL    |       |\n| name  | varchar(32) | YES  |     | NULL    |       |\n| phone | char(11)    | NO   |     |         |       |\n+-------+-------------+------+-----+---------+-------+\n\n\n*将t_student字段的类型和长度修改下\n\n语法：alter table 表名 modify 列名 新的类型名 新列参数;\n\nalter table t_student modify phone varchar(20);\nmysql> desc t_student;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| id    | int(10)     | YES  |     | NULL    |       |\n| name  | varchar(32) | YES  |     | NULL    |       |\n| phone | varchar(20) | YES  |     | NULL    |       |\n+-------+-------------+------+-----+---------+-------+\n\n\n*将t_student字段的名称、类型和长度修改下\n\n语法：alter table 表名 change 旧列名 新列名 新类型 新参数;\n\nalter table t_student change phone telphone varchar(26);\nmysql> desc t_student;\n+----------+-------------+------+-----+---------+-------+\n| Field    | Type        | Null | Key | Default | Extra |\n+----------+-------------+------+-----+---------+-------+\n| id       | int(10)     | YES  |     | NULL    |       |\n| name     | varchar(32) | YES  |     | NULL    |       |\n| telphone | varchar(26) | YES  |     | NULL    |       |\n+----------+-------------+------+-----+---------+-------+\n\n\n*将t_student表格中的telphone字段删除\nalter table t_student drop telphone;\nmysql> desc t_student;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| id    | int(10)     | YES  |     | NULL    |       |\n| name  | varchar(32) | YES  |     | NULL    |       |\n+-------+-------------+------+-----+---------+-------+\n\n13、增/删/改表结构[insert,delete,,update]\n\n\t13.1 update 语法格式：\n\t\tupdate tablename set 字段名1=字段值，字段名2=字段值2 ..where 条件;\n\n\t\t注：update语句没有条件限制，会将一张表中全部数据更新\n\t\tmysql> select * from t_student;\n\t\t+------+------+\n\t\t| id   | name |\n\t\t+------+------+\n\t\t|    1 | NULL |\n\t\t|    2 | NULL |\n\t\t+------+------+\n\n\t\t将id=2的name改为lisi\n\t\tupdate t_student set name='lisi' where id=2;\n\t\tmysql> select * from t_student;\n\t\t+------+------+\n\t\t| id   | name |\n\t\t+------+------+\n\t\t|    1 | NULL |\n\t\t|    2 | lisi |\n\t\t+------+------+\n\n\t13.2 delete\n\t格式：delete from tablename 条件\n\t注：若没条件限制，会将表中记录全部删除\n","slug":"MYSQL数据库笔记-7之表的创建","published":1,"updated":"2018-09-13T12:41:24.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm0r966i0006mlfiu256xlna","content":"<p>表</p>\n<p>1、表格，用来存储数据，表格是一种结构化文件</p>\n<p>2、表格行被 称为记录（表中的数据），表格列被称为字段。</p>\n<p>3、字段的属性：字段名称、字段数据类型、字段长度、字段约束</p>\n<a id=\"more\"></a>\n<p>4、创建表的语法：<br>    create table tablename(<br>        colunmnamedatatype(length),<br>        colunmnamedatatype(length),<br>        colunmnamedatatype(length),<br>        colunmnamedatatype(length),<br>        colunmnamedatatype(length)<br>    );</p>\n<p>5、关于MYSQL数据库中的类型：</p>\n<pre><code>- varchar\n    可变长度字符串\n    varchar（3）表示存储字符串长度不能超过3\n- char\n    定长字符串\n    char（3）表示存储字符串长度不能超过3\n\nvarchar和char对比：\n        - 都是字符串类型\n        - varchar比较智能，可能根据实际的数据长度分配空间，比较节省空间，但是在分配的时候需要执行相关的判断程序，效率较低。\n        - char不需要动态分配空间，所以执行效率很高，但是可能会导致空间浪费。\n        - 若字段中的数据不具备伸缩性，建议采用char类型存储。\n        - 若字段中的数据具备很强伸缩性，建议采用varchar类型存储。\n\n- int\n    整型\n    int（3）表示最大可以存储999\n- bigint\n    长整型\n- float\n    浮点型单精度\n    float（7,2）7表示7个有效数字，2表示小数位\n- double\n    浮点型双精度\n- date\n    日期类型\n    在实际开发中为了通用，所以日期类型一般不用，采用字符器串代替日期比较多。\n- blob\n    binary large object 二进制大对象\n    专门存储图片声音视频等数据\n    数据库中存储一个图片是很见的，但是存储一个较大的视频是很少的，一般都 是提供一个视频的的链接地址。\n- clob\n    charactor large object 字符大对象\n    可以存储一个比较大的文本，4G +的字符串\n- 其它。。。\n</code></pre><p>6、创建表格（学生表）<br>    建立学生信息表，字段包括：学号、姓名、性别、出生日期、eamil</p>\n<p>create table t_student(<br>    id int(10),<br>    name varchar(32),<br>    sex char(1),<br>    birth date,<br>    email varchar(128)<br>);</p>\n<pre><code>注：表格的名字是好以t_或tbl开头，增强可读性\n    varchar长度最好是2的倍数，方便存储中文\n</code></pre><p>删除表格：<br>    drop table t_student;这种删除方式，若数据库没有这样的表格，报错<br>    drop table if exists t_student;最好采用这种方式，只有MYSQL才能用</p>\n<p>7、向t_student表格中插入数据<br>    7.1语法格式：<br>        insert into tablename(columnname1,columnname2..) values(value1,value2…)<br>        字段和值必须一一对应，个数必须相同，数据类型必须一致<br>    7.2 向t_student插入数据<br>        insert into t_student(id,name,sex,birth,email) values(1,’zhangsan’,’m’,’1987-09-17’,<a href=\"mailto:&#39;zhangsan@qq.com\" target=\"_blank\" rel=\"noopener\">&#39;zhangsan@qq.com</a>‘);</p>\n<pre><code>insert into t_student(id,name,sex,birth,email) values(2,&apos;lisi&apos;,&apos;f&apos;,&apos;1987-09-27&apos;,&apos;lisi@qq.com&apos;);\n\nmysql&gt; select * from t_student;\n+------+----------+------+------------+-----------------+\n| id   | name     | sex  | birth      | email           |\n+------+----------+------+------------+-----------------+\n|    1 | zhangsan | m    | 1987-09-17 | zhangsan@qq.com |\n|    2 | lisi     | f    | 1987-09-27 | lisi@qq.com     |\n+------+----------+------+------------+-----------------+\n\ninsert into t_student(id,name) values(3,&apos;wangwu&apos;);\nmysql&gt; select * from t_student;\n+------+----------+------+------------+-----------------+\n| id   | name     | sex  | birth      | email           |\n+------+----------+------+------------+-----------------+\n|    1 | zhangsan | m    | 1987-09-17 | zhangsan@qq.com |\n|    2 | lisi     | f    | 1987-09-27 | lisi@qq.com     |\n|    3 | wangwu   | NULL | NULL       | NULL            |\n+------+----------+------+------------+-----------------+\n\n当一张表没有指定约束的话，可以为null值\n\n可以向sex、birth、eamil插入值吗？\nupdate语句进行更新数据操作\nupdate t_student set sex=&apos;m&apos;,birth=&apos;1999-02-10&apos;,email=&apos;wangwu@qq.com&apos; where id=3;\n\nmysql&gt; select * from t_student;\n+------+----------+------+------------+-----------------+\n| id   | name     | sex  | birth      | email           |\n+------+----------+------+------------+-----------------+\n|    1 | zhangsan | m    | 1987-09-17 | zhangsan@qq.com |\n|    2 | lisi     | f    | 1987-09-27 | lisi@qq.com     |\n|    3 | wangwu   | m    | 1999-02-10 | wangwu@qq.com   |\n+------+----------+------+------------+-----------------+\n</code></pre><p>关于SQL脚本：<br>    你是怎么看SQL脚本的？<br>    -该文件是一个普通的文本文件，后缀名.sql,称为SQL脚本</p>\n<pre><code>- 在SQL脚本中有大量的SQL语句，想指执行SQL语句，可以将这些SQL语句写入SQL脚本中，直接使用source执行脚本。\nsource 脚本文件路径\n</code></pre><p>9、获取系统当前时间：<br>    now()获取当前时间<br>    mysql&gt; select now();<br>    +———————+<br>    | now()               |<br>    +———————+<br>    | 2018-08-10 11:45:09 |<br>    +———————+</p>\n<pre><code>创建表，机构表：\n</code></pre><p>create table t_organization(<br>    code char(10),<br>    name varchar(32),<br>    createtime date<br>);</p>\n<p>insert into t_organization(code,name,createtime) values(‘111111’,’国家外汇局’,now());<br>insert into t_organization(code,name,createtime) values(‘111112’,’北京市外汇局’,now());<br>insert into t_organization(code,name,createtime) values(‘111113’,’海南省外汇局’,now());<br>insert into t_organization(code,name,createtime) values(‘111114’,’山东省外汇局’,now());<br>insert into t_organization(code,name,createtime) values(‘111115’,’福建省外汇局’,now());</p>\n<p>10、表的复制[快速创建表格]<br>语法：create table tablename1 as select columnname1,columnname2,…from tablename2;</p>\n<p>mysql&gt; create table emp1 as select ename,job,sal from emp;<br>+——–+———–+———+<br>| ename  | job       | sal     |<br>+——–+———–+———+<br>| SIMITH | CLERK     |  800.00 |<br>| ALLEN  | SALESMAN  | 1600.00 |<br>| WARD   | SALESMAN  | 1250.00 |<br>| JONES  | MANAGER   | 2975.00 |<br>| MARTIN | SALESMAN  | 1250.00 |<br>| BLAKE  | MANAGER   | 2850.00 |<br>| CLARK  | MANAGER   | 2450.00 |<br>| SCOTT  | ANALYST   | 3000.00 |<br>| KING   | PRESIDENT | 5000.00 |<br>| TURNER | SALESMAN  | 1500.00 |<br>| ADAMS  | CLERK     | 1100.00 |<br>| JAMES  | CLERK     |  950.00 |<br>| FORD   | ANALYST   | 3000.00 |<br>| MILLER | CLERK     | 1300.00 |<br>+——–+———–+———+</p>\n<p>11、将查询结果插入某张表中<br>mysql&gt; insert into emp1 select * from emp1 where sal=3000;</p>\n<p>mysql&gt; select * from emp1;<br>+——–+———–+———+<br>| ename  | job       | sal     |<br>+——–+———–+———+<br>| SIMITH | CLERK     |  800.00 |<br>| ALLEN  | SALESMAN  | 1600.00 |<br>| WARD   | SALESMAN  | 1250.00 |<br>| JONES  | MANAGER   | 2975.00 |<br>| MARTIN | SALESMAN  | 1250.00 |<br>| BLAKE  | MANAGER   | 2850.00 |<br>| CLARK  | MANAGER   | 2450.00 |<br>| SCOTT  | ANALYST   | 3000.00 |<br>| KING   | PRESIDENT | 5000.00 |<br>| TURNER | SALESMAN  | 1500.00 |<br>| ADAMS  | CLERK     | 1100.00 |<br>| JAMES  | CLERK     |  950.00 |<br>| FORD   | ANALYST   | 3000.00 |<br>| MILLER | CLERK     | 1300.00 |<br>| SCOTT  | ANALYST   | 3000.00 |<br>| FORD   | ANALYST   | 3000.00 |<br>+——–+———–+———+</p>\n<p>12、增/删/改 表结构</p>\n<p>drop table if exists t_student;<br>create table t_student(<br>    id int(10),<br>    name varchar(32)<br>);</p>\n<p>mysql&gt; desc t_student;<br>+——-+————-+——+—–+———+——-+<br>| Field | Type        | Null | Key | Default | Extra |<br>+——-+————-+——+—–+———+——-+<br>| id    | int(10)     | YES  |     | NULL    |       |<br>| name  | varchar(32) | YES  |     | NULL    |       |<br>+——-+————-+——+—–+———+——-+</p>\n<p>*给t_student表格添加一个联系电话字段<br>alter table t_student add phone char(11) not null default ‘’;</p>\n<p>mysql&gt; desc t_student;<br>+——-+————-+——+—–+———+——-+<br>| Field | Type        | Null | Key | Default | Extra |<br>+——-+————-+——+—–+———+——-+<br>| id    | int(10)     | YES  |     | NULL    |       |<br>| name  | varchar(32) | YES  |     | NULL    |       |<br>| phone | char(11)    | NO   |     |         |       |<br>+——-+————-+——+—–+———+——-+</p>\n<p>*将t_student字段的类型和长度修改下</p>\n<p>语法：alter table 表名 modify 列名 新的类型名 新列参数;</p>\n<p>alter table t_student modify phone varchar(20);<br>mysql&gt; desc t_student;<br>+——-+————-+——+—–+———+——-+<br>| Field | Type        | Null | Key | Default | Extra |<br>+——-+————-+——+—–+———+——-+<br>| id    | int(10)     | YES  |     | NULL    |       |<br>| name  | varchar(32) | YES  |     | NULL    |       |<br>| phone | varchar(20) | YES  |     | NULL    |       |<br>+——-+————-+——+—–+———+——-+</p>\n<p>*将t_student字段的名称、类型和长度修改下</p>\n<p>语法：alter table 表名 change 旧列名 新列名 新类型 新参数;</p>\n<p>alter table t_student change phone telphone varchar(26);<br>mysql&gt; desc t_student;<br>+———-+————-+——+—–+———+——-+<br>| Field    | Type        | Null | Key | Default | Extra |<br>+———-+————-+——+—–+———+——-+<br>| id       | int(10)     | YES  |     | NULL    |       |<br>| name     | varchar(32) | YES  |     | NULL    |       |<br>| telphone | varchar(26) | YES  |     | NULL    |       |<br>+———-+————-+——+—–+———+——-+</p>\n<p>*将t_student表格中的telphone字段删除<br>alter table t_student drop telphone;<br>mysql&gt; desc t_student;<br>+——-+————-+——+—–+———+——-+<br>| Field | Type        | Null | Key | Default | Extra |<br>+——-+————-+——+—–+———+——-+<br>| id    | int(10)     | YES  |     | NULL    |       |<br>| name  | varchar(32) | YES  |     | NULL    |       |<br>+——-+————-+——+—–+———+——-+</p>\n<p>13、增/删/改表结构[insert,delete,,update]</p>\n<pre><code>13.1 update 语法格式：\n    update tablename set 字段名1=字段值，字段名2=字段值2 ..where 条件;\n\n    注：update语句没有条件限制，会将一张表中全部数据更新\n    mysql&gt; select * from t_student;\n    +------+------+\n    | id   | name |\n    +------+------+\n    |    1 | NULL |\n    |    2 | NULL |\n    +------+------+\n\n    将id=2的name改为lisi\n    update t_student set name=&apos;lisi&apos; where id=2;\n    mysql&gt; select * from t_student;\n    +------+------+\n    | id   | name |\n    +------+------+\n    |    1 | NULL |\n    |    2 | lisi |\n    +------+------+\n\n13.2 delete\n格式：delete from tablename 条件\n注：若没条件限制，会将表中记录全部删除\n</code></pre>","site":{"data":{}},"excerpt":"<p>表</p>\n<p>1、表格，用来存储数据，表格是一种结构化文件</p>\n<p>2、表格行被 称为记录（表中的数据），表格列被称为字段。</p>\n<p>3、字段的属性：字段名称、字段数据类型、字段长度、字段约束</p>","more":"<p>4、创建表的语法：<br>    create table tablename(<br>        colunmnamedatatype(length),<br>        colunmnamedatatype(length),<br>        colunmnamedatatype(length),<br>        colunmnamedatatype(length),<br>        colunmnamedatatype(length)<br>    );</p>\n<p>5、关于MYSQL数据库中的类型：</p>\n<pre><code>- varchar\n    可变长度字符串\n    varchar（3）表示存储字符串长度不能超过3\n- char\n    定长字符串\n    char（3）表示存储字符串长度不能超过3\n\nvarchar和char对比：\n        - 都是字符串类型\n        - varchar比较智能，可能根据实际的数据长度分配空间，比较节省空间，但是在分配的时候需要执行相关的判断程序，效率较低。\n        - char不需要动态分配空间，所以执行效率很高，但是可能会导致空间浪费。\n        - 若字段中的数据不具备伸缩性，建议采用char类型存储。\n        - 若字段中的数据具备很强伸缩性，建议采用varchar类型存储。\n\n- int\n    整型\n    int（3）表示最大可以存储999\n- bigint\n    长整型\n- float\n    浮点型单精度\n    float（7,2）7表示7个有效数字，2表示小数位\n- double\n    浮点型双精度\n- date\n    日期类型\n    在实际开发中为了通用，所以日期类型一般不用，采用字符器串代替日期比较多。\n- blob\n    binary large object 二进制大对象\n    专门存储图片声音视频等数据\n    数据库中存储一个图片是很见的，但是存储一个较大的视频是很少的，一般都 是提供一个视频的的链接地址。\n- clob\n    charactor large object 字符大对象\n    可以存储一个比较大的文本，4G +的字符串\n- 其它。。。\n</code></pre><p>6、创建表格（学生表）<br>    建立学生信息表，字段包括：学号、姓名、性别、出生日期、eamil</p>\n<p>create table t_student(<br>    id int(10),<br>    name varchar(32),<br>    sex char(1),<br>    birth date,<br>    email varchar(128)<br>);</p>\n<pre><code>注：表格的名字是好以t_或tbl开头，增强可读性\n    varchar长度最好是2的倍数，方便存储中文\n</code></pre><p>删除表格：<br>    drop table t_student;这种删除方式，若数据库没有这样的表格，报错<br>    drop table if exists t_student;最好采用这种方式，只有MYSQL才能用</p>\n<p>7、向t_student表格中插入数据<br>    7.1语法格式：<br>        insert into tablename(columnname1,columnname2..) values(value1,value2…)<br>        字段和值必须一一对应，个数必须相同，数据类型必须一致<br>    7.2 向t_student插入数据<br>        insert into t_student(id,name,sex,birth,email) values(1,’zhangsan’,’m’,’1987-09-17’,<a href=\"mailto:&#39;zhangsan@qq.com\" target=\"_blank\" rel=\"noopener\">&#39;zhangsan@qq.com</a>‘);</p>\n<pre><code>insert into t_student(id,name,sex,birth,email) values(2,&apos;lisi&apos;,&apos;f&apos;,&apos;1987-09-27&apos;,&apos;lisi@qq.com&apos;);\n\nmysql&gt; select * from t_student;\n+------+----------+------+------------+-----------------+\n| id   | name     | sex  | birth      | email           |\n+------+----------+------+------------+-----------------+\n|    1 | zhangsan | m    | 1987-09-17 | zhangsan@qq.com |\n|    2 | lisi     | f    | 1987-09-27 | lisi@qq.com     |\n+------+----------+------+------------+-----------------+\n\ninsert into t_student(id,name) values(3,&apos;wangwu&apos;);\nmysql&gt; select * from t_student;\n+------+----------+------+------------+-----------------+\n| id   | name     | sex  | birth      | email           |\n+------+----------+------+------------+-----------------+\n|    1 | zhangsan | m    | 1987-09-17 | zhangsan@qq.com |\n|    2 | lisi     | f    | 1987-09-27 | lisi@qq.com     |\n|    3 | wangwu   | NULL | NULL       | NULL            |\n+------+----------+------+------------+-----------------+\n\n当一张表没有指定约束的话，可以为null值\n\n可以向sex、birth、eamil插入值吗？\nupdate语句进行更新数据操作\nupdate t_student set sex=&apos;m&apos;,birth=&apos;1999-02-10&apos;,email=&apos;wangwu@qq.com&apos; where id=3;\n\nmysql&gt; select * from t_student;\n+------+----------+------+------------+-----------------+\n| id   | name     | sex  | birth      | email           |\n+------+----------+------+------------+-----------------+\n|    1 | zhangsan | m    | 1987-09-17 | zhangsan@qq.com |\n|    2 | lisi     | f    | 1987-09-27 | lisi@qq.com     |\n|    3 | wangwu   | m    | 1999-02-10 | wangwu@qq.com   |\n+------+----------+------+------------+-----------------+\n</code></pre><p>关于SQL脚本：<br>    你是怎么看SQL脚本的？<br>    -该文件是一个普通的文本文件，后缀名.sql,称为SQL脚本</p>\n<pre><code>- 在SQL脚本中有大量的SQL语句，想指执行SQL语句，可以将这些SQL语句写入SQL脚本中，直接使用source执行脚本。\nsource 脚本文件路径\n</code></pre><p>9、获取系统当前时间：<br>    now()获取当前时间<br>    mysql&gt; select now();<br>    +———————+<br>    | now()               |<br>    +———————+<br>    | 2018-08-10 11:45:09 |<br>    +———————+</p>\n<pre><code>创建表，机构表：\n</code></pre><p>create table t_organization(<br>    code char(10),<br>    name varchar(32),<br>    createtime date<br>);</p>\n<p>insert into t_organization(code,name,createtime) values(‘111111’,’国家外汇局’,now());<br>insert into t_organization(code,name,createtime) values(‘111112’,’北京市外汇局’,now());<br>insert into t_organization(code,name,createtime) values(‘111113’,’海南省外汇局’,now());<br>insert into t_organization(code,name,createtime) values(‘111114’,’山东省外汇局’,now());<br>insert into t_organization(code,name,createtime) values(‘111115’,’福建省外汇局’,now());</p>\n<p>10、表的复制[快速创建表格]<br>语法：create table tablename1 as select columnname1,columnname2,…from tablename2;</p>\n<p>mysql&gt; create table emp1 as select ename,job,sal from emp;<br>+——–+———–+———+<br>| ename  | job       | sal     |<br>+——–+———–+———+<br>| SIMITH | CLERK     |  800.00 |<br>| ALLEN  | SALESMAN  | 1600.00 |<br>| WARD   | SALESMAN  | 1250.00 |<br>| JONES  | MANAGER   | 2975.00 |<br>| MARTIN | SALESMAN  | 1250.00 |<br>| BLAKE  | MANAGER   | 2850.00 |<br>| CLARK  | MANAGER   | 2450.00 |<br>| SCOTT  | ANALYST   | 3000.00 |<br>| KING   | PRESIDENT | 5000.00 |<br>| TURNER | SALESMAN  | 1500.00 |<br>| ADAMS  | CLERK     | 1100.00 |<br>| JAMES  | CLERK     |  950.00 |<br>| FORD   | ANALYST   | 3000.00 |<br>| MILLER | CLERK     | 1300.00 |<br>+——–+———–+———+</p>\n<p>11、将查询结果插入某张表中<br>mysql&gt; insert into emp1 select * from emp1 where sal=3000;</p>\n<p>mysql&gt; select * from emp1;<br>+——–+———–+———+<br>| ename  | job       | sal     |<br>+——–+———–+———+<br>| SIMITH | CLERK     |  800.00 |<br>| ALLEN  | SALESMAN  | 1600.00 |<br>| WARD   | SALESMAN  | 1250.00 |<br>| JONES  | MANAGER   | 2975.00 |<br>| MARTIN | SALESMAN  | 1250.00 |<br>| BLAKE  | MANAGER   | 2850.00 |<br>| CLARK  | MANAGER   | 2450.00 |<br>| SCOTT  | ANALYST   | 3000.00 |<br>| KING   | PRESIDENT | 5000.00 |<br>| TURNER | SALESMAN  | 1500.00 |<br>| ADAMS  | CLERK     | 1100.00 |<br>| JAMES  | CLERK     |  950.00 |<br>| FORD   | ANALYST   | 3000.00 |<br>| MILLER | CLERK     | 1300.00 |<br>| SCOTT  | ANALYST   | 3000.00 |<br>| FORD   | ANALYST   | 3000.00 |<br>+——–+———–+———+</p>\n<p>12、增/删/改 表结构</p>\n<p>drop table if exists t_student;<br>create table t_student(<br>    id int(10),<br>    name varchar(32)<br>);</p>\n<p>mysql&gt; desc t_student;<br>+——-+————-+——+—–+———+——-+<br>| Field | Type        | Null | Key | Default | Extra |<br>+——-+————-+——+—–+———+——-+<br>| id    | int(10)     | YES  |     | NULL    |       |<br>| name  | varchar(32) | YES  |     | NULL    |       |<br>+——-+————-+——+—–+———+——-+</p>\n<p>*给t_student表格添加一个联系电话字段<br>alter table t_student add phone char(11) not null default ‘’;</p>\n<p>mysql&gt; desc t_student;<br>+——-+————-+——+—–+———+——-+<br>| Field | Type        | Null | Key | Default | Extra |<br>+——-+————-+——+—–+———+——-+<br>| id    | int(10)     | YES  |     | NULL    |       |<br>| name  | varchar(32) | YES  |     | NULL    |       |<br>| phone | char(11)    | NO   |     |         |       |<br>+——-+————-+——+—–+———+——-+</p>\n<p>*将t_student字段的类型和长度修改下</p>\n<p>语法：alter table 表名 modify 列名 新的类型名 新列参数;</p>\n<p>alter table t_student modify phone varchar(20);<br>mysql&gt; desc t_student;<br>+——-+————-+——+—–+———+——-+<br>| Field | Type        | Null | Key | Default | Extra |<br>+——-+————-+——+—–+———+——-+<br>| id    | int(10)     | YES  |     | NULL    |       |<br>| name  | varchar(32) | YES  |     | NULL    |       |<br>| phone | varchar(20) | YES  |     | NULL    |       |<br>+——-+————-+——+—–+———+——-+</p>\n<p>*将t_student字段的名称、类型和长度修改下</p>\n<p>语法：alter table 表名 change 旧列名 新列名 新类型 新参数;</p>\n<p>alter table t_student change phone telphone varchar(26);<br>mysql&gt; desc t_student;<br>+———-+————-+——+—–+———+——-+<br>| Field    | Type        | Null | Key | Default | Extra |<br>+———-+————-+——+—–+———+——-+<br>| id       | int(10)     | YES  |     | NULL    |       |<br>| name     | varchar(32) | YES  |     | NULL    |       |<br>| telphone | varchar(26) | YES  |     | NULL    |       |<br>+———-+————-+——+—–+———+——-+</p>\n<p>*将t_student表格中的telphone字段删除<br>alter table t_student drop telphone;<br>mysql&gt; desc t_student;<br>+——-+————-+——+—–+———+——-+<br>| Field | Type        | Null | Key | Default | Extra |<br>+——-+————-+——+—–+———+——-+<br>| id    | int(10)     | YES  |     | NULL    |       |<br>| name  | varchar(32) | YES  |     | NULL    |       |<br>+——-+————-+——+—–+———+——-+</p>\n<p>13、增/删/改表结构[insert,delete,,update]</p>\n<pre><code>13.1 update 语法格式：\n    update tablename set 字段名1=字段值，字段名2=字段值2 ..where 条件;\n\n    注：update语句没有条件限制，会将一张表中全部数据更新\n    mysql&gt; select * from t_student;\n    +------+------+\n    | id   | name |\n    +------+------+\n    |    1 | NULL |\n    |    2 | NULL |\n    +------+------+\n\n    将id=2的name改为lisi\n    update t_student set name=&apos;lisi&apos; where id=2;\n    mysql&gt; select * from t_student;\n    +------+------+\n    | id   | name |\n    +------+------+\n    |    1 | NULL |\n    |    2 | lisi |\n    +------+------+\n\n13.2 delete\n格式：delete from tablename 条件\n注：若没条件限制，会将表中记录全部删除\n</code></pre>"},{"title":"MYSQL数据库笔记_8之约束","date":"2018-08-10T08:21:05.000Z","_content":"\n\n约束\n\n1.什么是约束，为什么要使用约束？\n\t- 约束对应的英语单词：constraint\n\t- 约束实际上就是表中数据的限制条件\n\t- 表在设计的时候加入约束的目的就是为了保证表中的记录完整有效。\n\n<!--more-->\n2、约束包括哪些？\n\t- 非空约束         not null\n\t- 唯一性约束\t\t  unique\n\t- 主键约束\t\t  primary key  PK\n\t- 外键约束\t\t  foreign key  FK\n\t- 检查约束  mysql不支持，oracle支持\n\n3、非空约束\n\t- not null约束的字段，不能为Null，必须给定具体数据\n\n\t 创建表，给字段添加非空约束（用户名不能为空）\n\tdrop table if exists t_user;\n\tcreate table t_user(\n\t\tid int(10),\n\t\tname varchar(32) not null,\n\t\temail varchar(128)\n\t);\n\n4、唯一性约束\n\t- unique约束的字段具有唯一性，不可重复\n\t\n\t//列级约束  \n\t创建用户，保证邮箱地址唯一\n\tdrop table if exists t_user;\n\tcreate table t_user(\n\t\tid int(10),\n\t\tname varchar(32),\n\t\temail varchar(128) unique\n\t);\n\n\tunique约束的字段不能重复，但可以为Null\n\n\n\tdrop table if exists t_user;\n\t//表级约束\n\tcreate table t_user(\n\t\tid int(10),\n\t\tname varchar(32) not null,\n\t\temail varchar(128), \n\t\tunique(email)\n\t);\n\n\t使用表级约束给多个字段联合添加约束(以下表示name和eamil两个字段联合唯一)\ndrop table if exists t_user;\n\ncreate table t_user(\n\tid int(10),\n\tname varchar(32) not null,\n\temail varchar(128),\n\tunique(name,email)\n);\n\ninsert into t_user(id,name,email) values(1,'abc','abc@qq.com');//OK\ninsert into t_user(id,name,email) values(2,'abc','def@qq.com');//OK\ninsert into t_user(id,name,email) values(3,'def','abc@qq.com');//OK\ninsert into t_user(id,name,email) values(4,'def','abc@qq.com');//FAIL 跟第三个重复\n\n\t- 表级约束还可以给约束起名字，\n\t- 为什么 要起名字？ 因为以后要通过名字来删除这个约束\ndrop table if exists t_user;\n\ncreate table t_user(\n\tid int(10),\n\tname varchar(32) not null,\n\temail varchar(128),\n\tconstraint t_user_email_name_unique unique(name,email)\n);\n//查询名字\nmysql> use information_schema;\n\nDatabase changed\nmysql> show tables;\n+---------------------------------------+\n| Tables_in_information_schema          |\n+---------------------------------------+\n| CHARACTER_SETS                        |\n| COLLATIONS                            |\n| COLLATION_CHARACTER_SET_APPLICABILITY |\n| COLUMNS                               |\n| COLUMN_PRIVILEGES                     |\n| ENGINES                               |\n| EVENTS                                |\n| FILES                                 |\n| GLOBAL_STATUS                         |\n| GLOBAL_VARIABLES                      |\n| KEY_COLUMN_USAGE                      |\n| OPTIMIZER_TRACE                       |\n| PARAMETERS                            |\n| PARTITIONS                            |\n| PLUGINS                               |\n| PROCESSLIST                           |\n| PROFILING                             |\n| REFERENTIAL_CONSTRAINTS               |\n| ROUTINES                              |\n| SCHEMATA                              |\n| SCHEMA_PRIVILEGES                     |\n| SESSION_STATUS                        |\n| SESSION_VARIABLES                     |\n| STATISTICS                            |\n| TABLES                                |\n| TABLESPACES                           |\n| TABLE_CONSTRAINTS                     |\n| TABLE_PRIVILEGES                      |\n| TRIGGERS                              |\n| USER_PRIVILEGES                       |\n| VIEWS                                 |\n| INNODB_LOCKS                          |\n| INNODB_TRX                            |\n| INNODB_SYS_DATAFILES                  |\n| INNODB_FT_CONFIG                      |\n| INNODB_SYS_VIRTUAL                    |\n| INNODB_CMP                            |\n| INNODB_FT_BEING_DELETED               |\n| INNODB_CMP_RESET                      |\n| INNODB_CMP_PER_INDEX                  |\n| INNODB_CMPMEM_RESET                   |\n| INNODB_FT_DELETED                     |\n| INNODB_BUFFER_PAGE_LRU                |\n| INNODB_LOCK_WAITS                     |\n| INNODB_TEMP_TABLE_INFO                |\n| INNODB_SYS_INDEXES                    |\n| INNODB_SYS_TABLES                     |\n| INNODB_SYS_FIELDS                     |\n| INNODB_CMP_PER_INDEX_RESET            |\n| INNODB_BUFFER_PAGE                    |\n| INNODB_FT_DEFAULT_STOPWORD            |\n| INNODB_FT_INDEX_TABLE                 |\n| INNODB_FT_INDEX_CACHE                 |\n| INNODB_SYS_TABLESPACES                |\n| INNODB_METRICS                        |\n| INNODB_SYS_FOREIGN_COLS               |\n| INNODB_CMPMEM                         |\n| INNODB_BUFFER_POOL_STATS              |\n| INNODB_SYS_COLUMNS                    |\n| INNODB_SYS_FOREIGN                    |\n| INNODB_SYS_TABLESTATS                 |\n+---------------------------------------+\n\nmysql> desc table_constraints;（该表格中专门存储约束信息）\n+--------------------+--------------+------+-----+---------+-------+\n| Field              | Type         | Null | Key | Default | Extra |\n+--------------------+--------------+------+-----+---------+-------+\n| CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |\n| CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |\n| CONSTRAINT_NAME    | varchar(64)  | NO   |     |         |       |\n| TABLE_SCHEMA       | varchar(64)  | NO   |     |         |       |\n| TABLE_NAME         | varchar(64)  | NO   |     |         |       |\n| CONSTRAINT_TYPE    | varchar(64)  | NO   |     |         |       |\n+--------------------+--------------+------+-----+---------+-------+\n6 rows in set (0.00 sec)\n\nmysql> select constraint_name from table_constraints where table_name='t_user';\n+--------------------------+\n| constraint_name          |\n+--------------------------+\n| t_user_email_name_unique |\n+--------------------------+\n\n5、not null和unique可以联合使用吗？\n\t- 可以联合使用\n\t- 被not null unique约束的字段，既不能为空，也不能重复\n\t- 例：\ndrop table if exists t_user;\ncreate table t_user(\n\tid int(10),\n\tname varchar(32) not null unique\n);\n\n\n6、主键约束-primary key 简称PK\n\t6.1主键涉及到的术语：\n\t\t-主键约束\n\t\t- 主键字段\n\t\t- 主键值\n\t6.2 以上的关系：\n\t\t表中的某个字段添加主键约束之后，该字段称为主键字段，主键字段中出现的每个值都被称为主键值。\n\n\t6.3 给某个字段添加主键约束之后，该字段不能重复，也不能为空。效果和“not null unique\"约束相同，但本质不同，主键字段还会默认添加”索引-index“\n\n\t6.4 和张表应该有主键字段，若没有，表示这张表是无效的。\n\t”主键值“是当前行数据的唯一标识。”主键值“是当前行数据的身份证号。\n\t即使表中现行记录相关的数据是相同的，但是由于主键值不同，我们认为这两行是完全不同的数据。\n\n\t6.5  给一个字段添加主键约束，称为单一主键。\n\t单一主键：\n\t//列级约束(这种方式用的多)\n\t\tdrop table if exists t_user;\n\t\tcreate table t_user(\n\t\t\tid int(10) primary key,\n\t\t\tname varchar(32)\n\t\t);\n\n\t单一主键：\n\t//表级约束\n\t\tdrop table if exists t_user;\n\t\tcreate table t_user(\n\t\t\tid int(10) ,\n\t\t\tname varchar(32)，\n\t\t\tprimary key(id)\n\t\t);\n\n\n\t单一主键：\n\t//表级约束\n\t//起名\n\t\tdrop table if exists t_user;\n\t\tcreate table t_user(\n\t\t\tid int(10) ,\n\t\t\tname varchar(32)，\n\t\t\tconstraint t_user_id_pk primary key(id)\n\t\t);\n\n\t6.6 给多个字段添加一个主键约束，称为复合主键。\n\t复合主键\n\t//表级约束\n\tdrop table if exists t_user;\n\t\tcreate table t_user(\n\t\t\tid int(10) ,\n\t\t\tname varchar(32)，\n\t\t\temail varchar(128),\n\t\t\tprimary key(id，name)\n\t\t);\n\n\n\t复合主键\n\t//表级约束\n\t//起名\n\tdrop table if exists t_user;\n\t\tcreate table t_user(\n\t\t\tid int(10) ,\n\t\t\tname varchar(32)，\n\t\t\temail varchar(128),\n\t\t\tconstraint t_user_id_pk primary key(id，name)\n\t\t);\n\n\t6.7 无论是单一主键还是复合主键，一张表主键约束只能有一个。\n\n\t6.8 主键根据性质分类：\n\t\t- 自然主键\n\t\t \t* 主键值若是一个自然数，这自然数和当前表的业务没有任何关系，这种主键叫做自然主键。\n\t\t- 业务主键\n\t\t\t* 主键值若和当前表中业务紧密相关的，这种主键值称为业务主键，当前业务数据发生改变的时候，主键值通常会受到影响，所以业务主键使用较少，大部分都 是使用自然主键。\n\n\t6.9  在\tMYSQL数据库管理系统中提供了一个自增的数字，专门用来自动生成主键值。\n\t主键值不需要用户维护，也不需要用户提供，自动生成。数字默认从1开始，以1递增\n\t1,2,3,4,5,6\n\tdrop table if exists t_user;\n\tcreate table t_user(\n\t\tid int(10) primary key auto_increment,\n\t\tname varchar(32)，\n\t);\n\n7、外键约束-foreign key 简称 FK\n\t\n\t7.1 外键涉及到的术语：\n\t\t-外键约束\n\t\t- 外键字段\n\t\t- 外键值\n\n\t7.2 以上的关系：\n\t\t表中的某个字段添加外键约束之后，该字段称为外键字段，外键字段中出现的每个值都被称为外键值。\n\n\t7.3 外键分为单一外键、复合外键\n\n\t7.4 一张表中可以有多个外键字段\n\n\t7.5 分析场景：\n\t请设计数据库表用来存储学生和班级信息，给出两种解决方案：\n\t学生信息和班级信息之间的关系，一个班级对应多个学生，这是典型的一对多的关系。\n\n\t第一种 ：将学生信息和班级信息存储到一张表中\n\t学生信息表t_student\n\tsno        sname      classno     cname\n\t-----------------------------------------\n\t1           jack         100      一班\n\t2           zhan         100      一班\n\t3           duck         200      二班\n\t4           fork         200      二班\n\t5           zhen         300      三班\n\t6           luck         400      三班\n\t以上的设计缺点：数据冗余\n\n\t第二种 ：学生信息和班级信息分开存储，学生表+班级表\n\t学生表t_student\n\tsno(pk)      sname      classno(fk)\n\t--------------------------\n\t1           a       \t100\n\t2           b       \t100\n\t3           c       \t200\n\t4           d       \t200\n\t5           e  \t\t\t300\n\t6           f\t\t\t300\n\n\t班级表t_class\n\tcno(pk)      cname\n\t--------------------\n\t100          一班       \n\t200          二班\n\t300          三班\n\t\n\t结论：为了保证t_student表中的classno字段中的\t数据必须来自于t_class表中cno字段中的数据，有必要给t_student表中的classno字段添加外键约束，classno字段被称为外键约束，字段中的100 200 300称为外键值，classno这里是单一外键字段。\n\n\t注：外键值可以为NULL\n\t\n\t注：外键字段去引用一张表的某个字段的时候，被引用的字段必须具有uniuqe约束。\n\t\n\t注：有了外键引用之后，表分了父表和子表，以上父表是班级表，子表是学生表 \n\t创建时先创建父表，再创建子表。删除时先删除子表中的数据，再删除父表中的数据，插入时先插入父表中的数据，再插入子表中的数据。 \n\n\t-----------------------SQL文----------------------------------\ndrop table if exists t_student;\ndrop table if exists t_class;\ncreate table t_class(\n\tcno int(3) primary key,\n\tcname varchar(32) not null\n);\ncreate table t_student(\n\tsno int(3) primary key,\n\tsname varchar(32) not null,\n\tclassno int(3),\n\tconstraint t_student_classno_fk foreign key(classno) references t_class(cno)\n);\ninsert into t_class(cno,cname) values(100,'一班');\ninsert into t_class(cno,cname) values(200,'二班');\ninsert into t_class(cno,cname) values(300,'三班');\ninsert into t_student(sno,sname,classno) values(1,'a',100);\ninsert into t_student(sno,sname,classno) values(2,'b',100);\ninsert into t_student(sno,sname,classno) values(3,'c',200);\ninsert into t_student(sno,sname,classno) values(4,'d',200);\ninsert into t_student(sno,sname,classno) values(5,'e',300);\ninsert into t_student(sno,sname,classno) values(6,'f',300);\nselect * from t_class;\nselect * from t_student;\n\n重点：典型的一对多的设计是在多的一方加外键\n\n\n8、级联更新和级联删除\n\t- 添加级联更新和删除时候，需要在外键约束后面添加\n\n\t- 在删除父表中数据的时候，级联删除子表中的数据    on delete cascade\n\t\t- 删除外键约束\n\t\t\talter table t_student drop foreign key t_student_classno_fk;\n\t\t- 添加外键约束\n\t\t\talter table t_student add constraint t_student_classno_fk foreign key(classno) references t_class(cno) on delete cascade;\n\t\n\t- 在更新父表中数据的时候，级联更新子表中的数据\t   on update cascade\n\t\t- 删除外键约束\n\t\t\talter table t_student drop foreign key t_student_classno_fk;\n\t\t- 添加外键约束\n\t\t\talter table t_student add constraint t_student_classno_fk foreign key(classno) references t_class(cno) on update cascade;\n\t\n\t- 以上的级联更新和级联删除，谨慎使用，因为级联操作会将数据改变或者删除\n","source":"_posts/MYSQL数据库笔记-8之约束.md","raw":"---\ntitle: MYSQL数据库笔记_8之约束\ndate: 2018-08-10 16:21:05\ntags:\n---\n\n\n约束\n\n1.什么是约束，为什么要使用约束？\n\t- 约束对应的英语单词：constraint\n\t- 约束实际上就是表中数据的限制条件\n\t- 表在设计的时候加入约束的目的就是为了保证表中的记录完整有效。\n\n<!--more-->\n2、约束包括哪些？\n\t- 非空约束         not null\n\t- 唯一性约束\t\t  unique\n\t- 主键约束\t\t  primary key  PK\n\t- 外键约束\t\t  foreign key  FK\n\t- 检查约束  mysql不支持，oracle支持\n\n3、非空约束\n\t- not null约束的字段，不能为Null，必须给定具体数据\n\n\t 创建表，给字段添加非空约束（用户名不能为空）\n\tdrop table if exists t_user;\n\tcreate table t_user(\n\t\tid int(10),\n\t\tname varchar(32) not null,\n\t\temail varchar(128)\n\t);\n\n4、唯一性约束\n\t- unique约束的字段具有唯一性，不可重复\n\t\n\t//列级约束  \n\t创建用户，保证邮箱地址唯一\n\tdrop table if exists t_user;\n\tcreate table t_user(\n\t\tid int(10),\n\t\tname varchar(32),\n\t\temail varchar(128) unique\n\t);\n\n\tunique约束的字段不能重复，但可以为Null\n\n\n\tdrop table if exists t_user;\n\t//表级约束\n\tcreate table t_user(\n\t\tid int(10),\n\t\tname varchar(32) not null,\n\t\temail varchar(128), \n\t\tunique(email)\n\t);\n\n\t使用表级约束给多个字段联合添加约束(以下表示name和eamil两个字段联合唯一)\ndrop table if exists t_user;\n\ncreate table t_user(\n\tid int(10),\n\tname varchar(32) not null,\n\temail varchar(128),\n\tunique(name,email)\n);\n\ninsert into t_user(id,name,email) values(1,'abc','abc@qq.com');//OK\ninsert into t_user(id,name,email) values(2,'abc','def@qq.com');//OK\ninsert into t_user(id,name,email) values(3,'def','abc@qq.com');//OK\ninsert into t_user(id,name,email) values(4,'def','abc@qq.com');//FAIL 跟第三个重复\n\n\t- 表级约束还可以给约束起名字，\n\t- 为什么 要起名字？ 因为以后要通过名字来删除这个约束\ndrop table if exists t_user;\n\ncreate table t_user(\n\tid int(10),\n\tname varchar(32) not null,\n\temail varchar(128),\n\tconstraint t_user_email_name_unique unique(name,email)\n);\n//查询名字\nmysql> use information_schema;\n\nDatabase changed\nmysql> show tables;\n+---------------------------------------+\n| Tables_in_information_schema          |\n+---------------------------------------+\n| CHARACTER_SETS                        |\n| COLLATIONS                            |\n| COLLATION_CHARACTER_SET_APPLICABILITY |\n| COLUMNS                               |\n| COLUMN_PRIVILEGES                     |\n| ENGINES                               |\n| EVENTS                                |\n| FILES                                 |\n| GLOBAL_STATUS                         |\n| GLOBAL_VARIABLES                      |\n| KEY_COLUMN_USAGE                      |\n| OPTIMIZER_TRACE                       |\n| PARAMETERS                            |\n| PARTITIONS                            |\n| PLUGINS                               |\n| PROCESSLIST                           |\n| PROFILING                             |\n| REFERENTIAL_CONSTRAINTS               |\n| ROUTINES                              |\n| SCHEMATA                              |\n| SCHEMA_PRIVILEGES                     |\n| SESSION_STATUS                        |\n| SESSION_VARIABLES                     |\n| STATISTICS                            |\n| TABLES                                |\n| TABLESPACES                           |\n| TABLE_CONSTRAINTS                     |\n| TABLE_PRIVILEGES                      |\n| TRIGGERS                              |\n| USER_PRIVILEGES                       |\n| VIEWS                                 |\n| INNODB_LOCKS                          |\n| INNODB_TRX                            |\n| INNODB_SYS_DATAFILES                  |\n| INNODB_FT_CONFIG                      |\n| INNODB_SYS_VIRTUAL                    |\n| INNODB_CMP                            |\n| INNODB_FT_BEING_DELETED               |\n| INNODB_CMP_RESET                      |\n| INNODB_CMP_PER_INDEX                  |\n| INNODB_CMPMEM_RESET                   |\n| INNODB_FT_DELETED                     |\n| INNODB_BUFFER_PAGE_LRU                |\n| INNODB_LOCK_WAITS                     |\n| INNODB_TEMP_TABLE_INFO                |\n| INNODB_SYS_INDEXES                    |\n| INNODB_SYS_TABLES                     |\n| INNODB_SYS_FIELDS                     |\n| INNODB_CMP_PER_INDEX_RESET            |\n| INNODB_BUFFER_PAGE                    |\n| INNODB_FT_DEFAULT_STOPWORD            |\n| INNODB_FT_INDEX_TABLE                 |\n| INNODB_FT_INDEX_CACHE                 |\n| INNODB_SYS_TABLESPACES                |\n| INNODB_METRICS                        |\n| INNODB_SYS_FOREIGN_COLS               |\n| INNODB_CMPMEM                         |\n| INNODB_BUFFER_POOL_STATS              |\n| INNODB_SYS_COLUMNS                    |\n| INNODB_SYS_FOREIGN                    |\n| INNODB_SYS_TABLESTATS                 |\n+---------------------------------------+\n\nmysql> desc table_constraints;（该表格中专门存储约束信息）\n+--------------------+--------------+------+-----+---------+-------+\n| Field              | Type         | Null | Key | Default | Extra |\n+--------------------+--------------+------+-----+---------+-------+\n| CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |\n| CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |\n| CONSTRAINT_NAME    | varchar(64)  | NO   |     |         |       |\n| TABLE_SCHEMA       | varchar(64)  | NO   |     |         |       |\n| TABLE_NAME         | varchar(64)  | NO   |     |         |       |\n| CONSTRAINT_TYPE    | varchar(64)  | NO   |     |         |       |\n+--------------------+--------------+------+-----+---------+-------+\n6 rows in set (0.00 sec)\n\nmysql> select constraint_name from table_constraints where table_name='t_user';\n+--------------------------+\n| constraint_name          |\n+--------------------------+\n| t_user_email_name_unique |\n+--------------------------+\n\n5、not null和unique可以联合使用吗？\n\t- 可以联合使用\n\t- 被not null unique约束的字段，既不能为空，也不能重复\n\t- 例：\ndrop table if exists t_user;\ncreate table t_user(\n\tid int(10),\n\tname varchar(32) not null unique\n);\n\n\n6、主键约束-primary key 简称PK\n\t6.1主键涉及到的术语：\n\t\t-主键约束\n\t\t- 主键字段\n\t\t- 主键值\n\t6.2 以上的关系：\n\t\t表中的某个字段添加主键约束之后，该字段称为主键字段，主键字段中出现的每个值都被称为主键值。\n\n\t6.3 给某个字段添加主键约束之后，该字段不能重复，也不能为空。效果和“not null unique\"约束相同，但本质不同，主键字段还会默认添加”索引-index“\n\n\t6.4 和张表应该有主键字段，若没有，表示这张表是无效的。\n\t”主键值“是当前行数据的唯一标识。”主键值“是当前行数据的身份证号。\n\t即使表中现行记录相关的数据是相同的，但是由于主键值不同，我们认为这两行是完全不同的数据。\n\n\t6.5  给一个字段添加主键约束，称为单一主键。\n\t单一主键：\n\t//列级约束(这种方式用的多)\n\t\tdrop table if exists t_user;\n\t\tcreate table t_user(\n\t\t\tid int(10) primary key,\n\t\t\tname varchar(32)\n\t\t);\n\n\t单一主键：\n\t//表级约束\n\t\tdrop table if exists t_user;\n\t\tcreate table t_user(\n\t\t\tid int(10) ,\n\t\t\tname varchar(32)，\n\t\t\tprimary key(id)\n\t\t);\n\n\n\t单一主键：\n\t//表级约束\n\t//起名\n\t\tdrop table if exists t_user;\n\t\tcreate table t_user(\n\t\t\tid int(10) ,\n\t\t\tname varchar(32)，\n\t\t\tconstraint t_user_id_pk primary key(id)\n\t\t);\n\n\t6.6 给多个字段添加一个主键约束，称为复合主键。\n\t复合主键\n\t//表级约束\n\tdrop table if exists t_user;\n\t\tcreate table t_user(\n\t\t\tid int(10) ,\n\t\t\tname varchar(32)，\n\t\t\temail varchar(128),\n\t\t\tprimary key(id，name)\n\t\t);\n\n\n\t复合主键\n\t//表级约束\n\t//起名\n\tdrop table if exists t_user;\n\t\tcreate table t_user(\n\t\t\tid int(10) ,\n\t\t\tname varchar(32)，\n\t\t\temail varchar(128),\n\t\t\tconstraint t_user_id_pk primary key(id，name)\n\t\t);\n\n\t6.7 无论是单一主键还是复合主键，一张表主键约束只能有一个。\n\n\t6.8 主键根据性质分类：\n\t\t- 自然主键\n\t\t \t* 主键值若是一个自然数，这自然数和当前表的业务没有任何关系，这种主键叫做自然主键。\n\t\t- 业务主键\n\t\t\t* 主键值若和当前表中业务紧密相关的，这种主键值称为业务主键，当前业务数据发生改变的时候，主键值通常会受到影响，所以业务主键使用较少，大部分都 是使用自然主键。\n\n\t6.9  在\tMYSQL数据库管理系统中提供了一个自增的数字，专门用来自动生成主键值。\n\t主键值不需要用户维护，也不需要用户提供，自动生成。数字默认从1开始，以1递增\n\t1,2,3,4,5,6\n\tdrop table if exists t_user;\n\tcreate table t_user(\n\t\tid int(10) primary key auto_increment,\n\t\tname varchar(32)，\n\t);\n\n7、外键约束-foreign key 简称 FK\n\t\n\t7.1 外键涉及到的术语：\n\t\t-外键约束\n\t\t- 外键字段\n\t\t- 外键值\n\n\t7.2 以上的关系：\n\t\t表中的某个字段添加外键约束之后，该字段称为外键字段，外键字段中出现的每个值都被称为外键值。\n\n\t7.3 外键分为单一外键、复合外键\n\n\t7.4 一张表中可以有多个外键字段\n\n\t7.5 分析场景：\n\t请设计数据库表用来存储学生和班级信息，给出两种解决方案：\n\t学生信息和班级信息之间的关系，一个班级对应多个学生，这是典型的一对多的关系。\n\n\t第一种 ：将学生信息和班级信息存储到一张表中\n\t学生信息表t_student\n\tsno        sname      classno     cname\n\t-----------------------------------------\n\t1           jack         100      一班\n\t2           zhan         100      一班\n\t3           duck         200      二班\n\t4           fork         200      二班\n\t5           zhen         300      三班\n\t6           luck         400      三班\n\t以上的设计缺点：数据冗余\n\n\t第二种 ：学生信息和班级信息分开存储，学生表+班级表\n\t学生表t_student\n\tsno(pk)      sname      classno(fk)\n\t--------------------------\n\t1           a       \t100\n\t2           b       \t100\n\t3           c       \t200\n\t4           d       \t200\n\t5           e  \t\t\t300\n\t6           f\t\t\t300\n\n\t班级表t_class\n\tcno(pk)      cname\n\t--------------------\n\t100          一班       \n\t200          二班\n\t300          三班\n\t\n\t结论：为了保证t_student表中的classno字段中的\t数据必须来自于t_class表中cno字段中的数据，有必要给t_student表中的classno字段添加外键约束，classno字段被称为外键约束，字段中的100 200 300称为外键值，classno这里是单一外键字段。\n\n\t注：外键值可以为NULL\n\t\n\t注：外键字段去引用一张表的某个字段的时候，被引用的字段必须具有uniuqe约束。\n\t\n\t注：有了外键引用之后，表分了父表和子表，以上父表是班级表，子表是学生表 \n\t创建时先创建父表，再创建子表。删除时先删除子表中的数据，再删除父表中的数据，插入时先插入父表中的数据，再插入子表中的数据。 \n\n\t-----------------------SQL文----------------------------------\ndrop table if exists t_student;\ndrop table if exists t_class;\ncreate table t_class(\n\tcno int(3) primary key,\n\tcname varchar(32) not null\n);\ncreate table t_student(\n\tsno int(3) primary key,\n\tsname varchar(32) not null,\n\tclassno int(3),\n\tconstraint t_student_classno_fk foreign key(classno) references t_class(cno)\n);\ninsert into t_class(cno,cname) values(100,'一班');\ninsert into t_class(cno,cname) values(200,'二班');\ninsert into t_class(cno,cname) values(300,'三班');\ninsert into t_student(sno,sname,classno) values(1,'a',100);\ninsert into t_student(sno,sname,classno) values(2,'b',100);\ninsert into t_student(sno,sname,classno) values(3,'c',200);\ninsert into t_student(sno,sname,classno) values(4,'d',200);\ninsert into t_student(sno,sname,classno) values(5,'e',300);\ninsert into t_student(sno,sname,classno) values(6,'f',300);\nselect * from t_class;\nselect * from t_student;\n\n重点：典型的一对多的设计是在多的一方加外键\n\n\n8、级联更新和级联删除\n\t- 添加级联更新和删除时候，需要在外键约束后面添加\n\n\t- 在删除父表中数据的时候，级联删除子表中的数据    on delete cascade\n\t\t- 删除外键约束\n\t\t\talter table t_student drop foreign key t_student_classno_fk;\n\t\t- 添加外键约束\n\t\t\talter table t_student add constraint t_student_classno_fk foreign key(classno) references t_class(cno) on delete cascade;\n\t\n\t- 在更新父表中数据的时候，级联更新子表中的数据\t   on update cascade\n\t\t- 删除外键约束\n\t\t\talter table t_student drop foreign key t_student_classno_fk;\n\t\t- 添加外键约束\n\t\t\talter table t_student add constraint t_student_classno_fk foreign key(classno) references t_class(cno) on update cascade;\n\t\n\t- 以上的级联更新和级联删除，谨慎使用，因为级联操作会将数据改变或者删除\n","slug":"MYSQL数据库笔记-8之约束","published":1,"updated":"2018-09-13T12:41:24.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm0r966j0007mlfiffcpmk2g","content":"<p>约束</p>\n<p>1.什么是约束，为什么要使用约束？</p>\n<pre><code>- 约束对应的英语单词：constraint\n- 约束实际上就是表中数据的限制条件\n- 表在设计的时候加入约束的目的就是为了保证表中的记录完整有效。\n</code></pre><a id=\"more\"></a>\n<p>2、约束包括哪些？</p>\n<pre><code>- 非空约束         not null\n- 唯一性约束          unique\n- 主键约束          primary key  PK\n- 外键约束          foreign key  FK\n- 检查约束  mysql不支持，oracle支持\n</code></pre><p>3、非空约束</p>\n<pre><code>- not null约束的字段，不能为Null，必须给定具体数据\n\n 创建表，给字段添加非空约束（用户名不能为空）\ndrop table if exists t_user;\ncreate table t_user(\n    id int(10),\n    name varchar(32) not null,\n    email varchar(128)\n);\n</code></pre><p>4、唯一性约束</p>\n<pre><code>- unique约束的字段具有唯一性，不可重复\n\n//列级约束  \n创建用户，保证邮箱地址唯一\ndrop table if exists t_user;\ncreate table t_user(\n    id int(10),\n    name varchar(32),\n    email varchar(128) unique\n);\n\nunique约束的字段不能重复，但可以为Null\n\n\ndrop table if exists t_user;\n//表级约束\ncreate table t_user(\n    id int(10),\n    name varchar(32) not null,\n    email varchar(128), \n    unique(email)\n);\n\n使用表级约束给多个字段联合添加约束(以下表示name和eamil两个字段联合唯一)\n</code></pre><p>drop table if exists t_user;</p>\n<p>create table t_user(<br>    id int(10),<br>    name varchar(32) not null,<br>    email varchar(128),<br>    unique(name,email)<br>);</p>\n<p>insert into t_user(id,name,email) values(1,’abc’,<a href=\"mailto:&#39;abc@qq.com\" target=\"_blank\" rel=\"noopener\">&#39;abc@qq.com</a>‘);//OK<br>insert into t_user(id,name,email) values(2,’abc’,<a href=\"mailto:&#39;def@qq.com\" target=\"_blank\" rel=\"noopener\">&#39;def@qq.com</a>‘);//OK<br>insert into t_user(id,name,email) values(3,’def’,<a href=\"mailto:&#39;abc@qq.com\" target=\"_blank\" rel=\"noopener\">&#39;abc@qq.com</a>‘);//OK<br>insert into t_user(id,name,email) values(4,’def’,<a href=\"mailto:&#39;abc@qq.com\" target=\"_blank\" rel=\"noopener\">&#39;abc@qq.com</a>‘);//FAIL 跟第三个重复</p>\n<pre><code>- 表级约束还可以给约束起名字，\n- 为什么 要起名字？ 因为以后要通过名字来删除这个约束\n</code></pre><p>drop table if exists t_user;</p>\n<p>create table t_user(<br>    id int(10),<br>    name varchar(32) not null,<br>    email varchar(128),<br>    constraint t_user_email_name_unique unique(name,email)<br>);<br>//查询名字<br>mysql&gt; use information_schema;</p>\n<p>Database changed<br>mysql&gt; show tables;<br>+—————————————+<br>| Tables_in_information_schema          |<br>+—————————————+<br>| CHARACTER_SETS                        |<br>| COLLATIONS                            |<br>| COLLATION_CHARACTER_SET_APPLICABILITY |<br>| COLUMNS                               |<br>| COLUMN_PRIVILEGES                     |<br>| ENGINES                               |<br>| EVENTS                                |<br>| FILES                                 |<br>| GLOBAL_STATUS                         |<br>| GLOBAL_VARIABLES                      |<br>| KEY_COLUMN_USAGE                      |<br>| OPTIMIZER_TRACE                       |<br>| PARAMETERS                            |<br>| PARTITIONS                            |<br>| PLUGINS                               |<br>| PROCESSLIST                           |<br>| PROFILING                             |<br>| REFERENTIAL_CONSTRAINTS               |<br>| ROUTINES                              |<br>| SCHEMATA                              |<br>| SCHEMA_PRIVILEGES                     |<br>| SESSION_STATUS                        |<br>| SESSION_VARIABLES                     |<br>| STATISTICS                            |<br>| TABLES                                |<br>| TABLESPACES                           |<br>| TABLE_CONSTRAINTS                     |<br>| TABLE_PRIVILEGES                      |<br>| TRIGGERS                              |<br>| USER_PRIVILEGES                       |<br>| VIEWS                                 |<br>| INNODB_LOCKS                          |<br>| INNODB_TRX                            |<br>| INNODB_SYS_DATAFILES                  |<br>| INNODB_FT_CONFIG                      |<br>| INNODB_SYS_VIRTUAL                    |<br>| INNODB_CMP                            |<br>| INNODB_FT_BEING_DELETED               |<br>| INNODB_CMP_RESET                      |<br>| INNODB_CMP_PER_INDEX                  |<br>| INNODB_CMPMEM_RESET                   |<br>| INNODB_FT_DELETED                     |<br>| INNODB_BUFFER_PAGE_LRU                |<br>| INNODB_LOCK_WAITS                     |<br>| INNODB_TEMP_TABLE_INFO                |<br>| INNODB_SYS_INDEXES                    |<br>| INNODB_SYS_TABLES                     |<br>| INNODB_SYS_FIELDS                     |<br>| INNODB_CMP_PER_INDEX_RESET            |<br>| INNODB_BUFFER_PAGE                    |<br>| INNODB_FT_DEFAULT_STOPWORD            |<br>| INNODB_FT_INDEX_TABLE                 |<br>| INNODB_FT_INDEX_CACHE                 |<br>| INNODB_SYS_TABLESPACES                |<br>| INNODB_METRICS                        |<br>| INNODB_SYS_FOREIGN_COLS               |<br>| INNODB_CMPMEM                         |<br>| INNODB_BUFFER_POOL_STATS              |<br>| INNODB_SYS_COLUMNS                    |<br>| INNODB_SYS_FOREIGN                    |<br>| INNODB_SYS_TABLESTATS                 |<br>+—————————————+</p>\n<p>mysql&gt; desc table_constraints;（该表格中专门存储约束信息）<br>+——————–+————–+——+—–+———+——-+<br>| Field              | Type         | Null | Key | Default | Extra |<br>+——————–+————–+——+—–+———+——-+<br>| CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |<br>| CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |<br>| CONSTRAINT_NAME    | varchar(64)  | NO   |     |         |       |<br>| TABLE_SCHEMA       | varchar(64)  | NO   |     |         |       |<br>| TABLE_NAME         | varchar(64)  | NO   |     |         |       |<br>| CONSTRAINT_TYPE    | varchar(64)  | NO   |     |         |       |<br>+——————–+————–+——+—–+———+——-+<br>6 rows in set (0.00 sec)</p>\n<p>mysql&gt; select constraint_name from table_constraints where table_name=’t_user’;<br>+————————–+<br>| constraint_name          |<br>+————————–+<br>| t_user_email_name_unique |<br>+————————–+</p>\n<p>5、not null和unique可以联合使用吗？</p>\n<pre><code>- 可以联合使用\n- 被not null unique约束的字段，既不能为空，也不能重复\n- 例：\n</code></pre><p>drop table if exists t_user;<br>create table t_user(<br>    id int(10),<br>    name varchar(32) not null unique<br>);</p>\n<p>6、主键约束-primary key 简称PK<br>    6.1主键涉及到的术语：<br>        -主键约束</p>\n<pre><code>    - 主键字段\n    - 主键值\n6.2 以上的关系：\n    表中的某个字段添加主键约束之后，该字段称为主键字段，主键字段中出现的每个值都被称为主键值。\n\n6.3 给某个字段添加主键约束之后，该字段不能重复，也不能为空。效果和“not null unique&quot;约束相同，但本质不同，主键字段还会默认添加”索引-index“\n\n6.4 和张表应该有主键字段，若没有，表示这张表是无效的。\n”主键值“是当前行数据的唯一标识。”主键值“是当前行数据的身份证号。\n即使表中现行记录相关的数据是相同的，但是由于主键值不同，我们认为这两行是完全不同的数据。\n\n6.5  给一个字段添加主键约束，称为单一主键。\n单一主键：\n//列级约束(这种方式用的多)\n    drop table if exists t_user;\n    create table t_user(\n        id int(10) primary key,\n        name varchar(32)\n    );\n\n单一主键：\n//表级约束\n    drop table if exists t_user;\n    create table t_user(\n        id int(10) ,\n        name varchar(32)，\n        primary key(id)\n    );\n\n\n单一主键：\n//表级约束\n//起名\n    drop table if exists t_user;\n    create table t_user(\n        id int(10) ,\n        name varchar(32)，\n        constraint t_user_id_pk primary key(id)\n    );\n\n6.6 给多个字段添加一个主键约束，称为复合主键。\n复合主键\n//表级约束\ndrop table if exists t_user;\n    create table t_user(\n        id int(10) ,\n        name varchar(32)，\n        email varchar(128),\n        primary key(id，name)\n    );\n\n\n复合主键\n//表级约束\n//起名\ndrop table if exists t_user;\n    create table t_user(\n        id int(10) ,\n        name varchar(32)，\n        email varchar(128),\n        constraint t_user_id_pk primary key(id，name)\n    );\n\n6.7 无论是单一主键还是复合主键，一张表主键约束只能有一个。\n\n6.8 主键根据性质分类：\n    - 自然主键\n         * 主键值若是一个自然数，这自然数和当前表的业务没有任何关系，这种主键叫做自然主键。\n    - 业务主键\n        * 主键值若和当前表中业务紧密相关的，这种主键值称为业务主键，当前业务数据发生改变的时候，主键值通常会受到影响，所以业务主键使用较少，大部分都 是使用自然主键。\n\n6.9  在    MYSQL数据库管理系统中提供了一个自增的数字，专门用来自动生成主键值。\n主键值不需要用户维护，也不需要用户提供，自动生成。数字默认从1开始，以1递增\n1,2,3,4,5,6\ndrop table if exists t_user;\ncreate table t_user(\n    id int(10) primary key auto_increment,\n    name varchar(32)，\n);\n</code></pre><p>7、外键约束-foreign key 简称 FK</p>\n<pre><code>7.1 外键涉及到的术语：\n    -外键约束\n    - 外键字段\n    - 外键值\n\n7.2 以上的关系：\n    表中的某个字段添加外键约束之后，该字段称为外键字段，外键字段中出现的每个值都被称为外键值。\n\n7.3 外键分为单一外键、复合外键\n\n7.4 一张表中可以有多个外键字段\n\n7.5 分析场景：\n请设计数据库表用来存储学生和班级信息，给出两种解决方案：\n学生信息和班级信息之间的关系，一个班级对应多个学生，这是典型的一对多的关系。\n\n第一种 ：将学生信息和班级信息存储到一张表中\n学生信息表t_student\nsno        sname      classno     cname\n-----------------------------------------\n1           jack         100      一班\n2           zhan         100      一班\n3           duck         200      二班\n4           fork         200      二班\n5           zhen         300      三班\n6           luck         400      三班\n以上的设计缺点：数据冗余\n\n第二种 ：学生信息和班级信息分开存储，学生表+班级表\n学生表t_student\nsno(pk)      sname      classno(fk)\n--------------------------\n1           a           100\n2           b           100\n3           c           200\n4           d           200\n5           e              300\n6           f            300\n\n班级表t_class\ncno(pk)      cname\n--------------------\n100          一班       \n200          二班\n300          三班\n\n结论：为了保证t_student表中的classno字段中的    数据必须来自于t_class表中cno字段中的数据，有必要给t_student表中的classno字段添加外键约束，classno字段被称为外键约束，字段中的100 200 300称为外键值，classno这里是单一外键字段。\n\n注：外键值可以为NULL\n\n注：外键字段去引用一张表的某个字段的时候，被引用的字段必须具有uniuqe约束。\n\n注：有了外键引用之后，表分了父表和子表，以上父表是班级表，子表是学生表 \n创建时先创建父表，再创建子表。删除时先删除子表中的数据，再删除父表中的数据，插入时先插入父表中的数据，再插入子表中的数据。 \n\n-----------------------SQL文----------------------------------\n</code></pre><p>drop table if exists t_student;<br>drop table if exists t_class;<br>create table t_class(<br>    cno int(3) primary key,<br>    cname varchar(32) not null<br>);<br>create table t_student(<br>    sno int(3) primary key,<br>    sname varchar(32) not null,<br>    classno int(3),<br>    constraint t_student_classno_fk foreign key(classno) references t_class(cno)<br>);<br>insert into t_class(cno,cname) values(100,’一班’);<br>insert into t_class(cno,cname) values(200,’二班’);<br>insert into t_class(cno,cname) values(300,’三班’);<br>insert into t_student(sno,sname,classno) values(1,’a’,100);<br>insert into t_student(sno,sname,classno) values(2,’b’,100);<br>insert into t_student(sno,sname,classno) values(3,’c’,200);<br>insert into t_student(sno,sname,classno) values(4,’d’,200);<br>insert into t_student(sno,sname,classno) values(5,’e’,300);<br>insert into t_student(sno,sname,classno) values(6,’f’,300);<br>select <em> from t_class;<br>select </em> from t_student;</p>\n<p>重点：典型的一对多的设计是在多的一方加外键</p>\n<p>8、级联更新和级联删除</p>\n<pre><code>- 添加级联更新和删除时候，需要在外键约束后面添加\n\n- 在删除父表中数据的时候，级联删除子表中的数据    on delete cascade\n    - 删除外键约束\n        alter table t_student drop foreign key t_student_classno_fk;\n    - 添加外键约束\n        alter table t_student add constraint t_student_classno_fk foreign key(classno) references t_class(cno) on delete cascade;\n\n- 在更新父表中数据的时候，级联更新子表中的数据       on update cascade\n    - 删除外键约束\n        alter table t_student drop foreign key t_student_classno_fk;\n    - 添加外键约束\n        alter table t_student add constraint t_student_classno_fk foreign key(classno) references t_class(cno) on update cascade;\n\n- 以上的级联更新和级联删除，谨慎使用，因为级联操作会将数据改变或者删除\n</code></pre>","site":{"data":{}},"excerpt":"<p>约束</p>\n<p>1.什么是约束，为什么要使用约束？</p>\n<pre><code>- 约束对应的英语单词：constraint\n- 约束实际上就是表中数据的限制条件\n- 表在设计的时候加入约束的目的就是为了保证表中的记录完整有效。\n</code></pre>","more":"<p>2、约束包括哪些？</p>\n<pre><code>- 非空约束         not null\n- 唯一性约束          unique\n- 主键约束          primary key  PK\n- 外键约束          foreign key  FK\n- 检查约束  mysql不支持，oracle支持\n</code></pre><p>3、非空约束</p>\n<pre><code>- not null约束的字段，不能为Null，必须给定具体数据\n\n 创建表，给字段添加非空约束（用户名不能为空）\ndrop table if exists t_user;\ncreate table t_user(\n    id int(10),\n    name varchar(32) not null,\n    email varchar(128)\n);\n</code></pre><p>4、唯一性约束</p>\n<pre><code>- unique约束的字段具有唯一性，不可重复\n\n//列级约束  \n创建用户，保证邮箱地址唯一\ndrop table if exists t_user;\ncreate table t_user(\n    id int(10),\n    name varchar(32),\n    email varchar(128) unique\n);\n\nunique约束的字段不能重复，但可以为Null\n\n\ndrop table if exists t_user;\n//表级约束\ncreate table t_user(\n    id int(10),\n    name varchar(32) not null,\n    email varchar(128), \n    unique(email)\n);\n\n使用表级约束给多个字段联合添加约束(以下表示name和eamil两个字段联合唯一)\n</code></pre><p>drop table if exists t_user;</p>\n<p>create table t_user(<br>    id int(10),<br>    name varchar(32) not null,<br>    email varchar(128),<br>    unique(name,email)<br>);</p>\n<p>insert into t_user(id,name,email) values(1,’abc’,<a href=\"mailto:&#39;abc@qq.com\" target=\"_blank\" rel=\"noopener\">&#39;abc@qq.com</a>‘);//OK<br>insert into t_user(id,name,email) values(2,’abc’,<a href=\"mailto:&#39;def@qq.com\" target=\"_blank\" rel=\"noopener\">&#39;def@qq.com</a>‘);//OK<br>insert into t_user(id,name,email) values(3,’def’,<a href=\"mailto:&#39;abc@qq.com\" target=\"_blank\" rel=\"noopener\">&#39;abc@qq.com</a>‘);//OK<br>insert into t_user(id,name,email) values(4,’def’,<a href=\"mailto:&#39;abc@qq.com\" target=\"_blank\" rel=\"noopener\">&#39;abc@qq.com</a>‘);//FAIL 跟第三个重复</p>\n<pre><code>- 表级约束还可以给约束起名字，\n- 为什么 要起名字？ 因为以后要通过名字来删除这个约束\n</code></pre><p>drop table if exists t_user;</p>\n<p>create table t_user(<br>    id int(10),<br>    name varchar(32) not null,<br>    email varchar(128),<br>    constraint t_user_email_name_unique unique(name,email)<br>);<br>//查询名字<br>mysql&gt; use information_schema;</p>\n<p>Database changed<br>mysql&gt; show tables;<br>+—————————————+<br>| Tables_in_information_schema          |<br>+—————————————+<br>| CHARACTER_SETS                        |<br>| COLLATIONS                            |<br>| COLLATION_CHARACTER_SET_APPLICABILITY |<br>| COLUMNS                               |<br>| COLUMN_PRIVILEGES                     |<br>| ENGINES                               |<br>| EVENTS                                |<br>| FILES                                 |<br>| GLOBAL_STATUS                         |<br>| GLOBAL_VARIABLES                      |<br>| KEY_COLUMN_USAGE                      |<br>| OPTIMIZER_TRACE                       |<br>| PARAMETERS                            |<br>| PARTITIONS                            |<br>| PLUGINS                               |<br>| PROCESSLIST                           |<br>| PROFILING                             |<br>| REFERENTIAL_CONSTRAINTS               |<br>| ROUTINES                              |<br>| SCHEMATA                              |<br>| SCHEMA_PRIVILEGES                     |<br>| SESSION_STATUS                        |<br>| SESSION_VARIABLES                     |<br>| STATISTICS                            |<br>| TABLES                                |<br>| TABLESPACES                           |<br>| TABLE_CONSTRAINTS                     |<br>| TABLE_PRIVILEGES                      |<br>| TRIGGERS                              |<br>| USER_PRIVILEGES                       |<br>| VIEWS                                 |<br>| INNODB_LOCKS                          |<br>| INNODB_TRX                            |<br>| INNODB_SYS_DATAFILES                  |<br>| INNODB_FT_CONFIG                      |<br>| INNODB_SYS_VIRTUAL                    |<br>| INNODB_CMP                            |<br>| INNODB_FT_BEING_DELETED               |<br>| INNODB_CMP_RESET                      |<br>| INNODB_CMP_PER_INDEX                  |<br>| INNODB_CMPMEM_RESET                   |<br>| INNODB_FT_DELETED                     |<br>| INNODB_BUFFER_PAGE_LRU                |<br>| INNODB_LOCK_WAITS                     |<br>| INNODB_TEMP_TABLE_INFO                |<br>| INNODB_SYS_INDEXES                    |<br>| INNODB_SYS_TABLES                     |<br>| INNODB_SYS_FIELDS                     |<br>| INNODB_CMP_PER_INDEX_RESET            |<br>| INNODB_BUFFER_PAGE                    |<br>| INNODB_FT_DEFAULT_STOPWORD            |<br>| INNODB_FT_INDEX_TABLE                 |<br>| INNODB_FT_INDEX_CACHE                 |<br>| INNODB_SYS_TABLESPACES                |<br>| INNODB_METRICS                        |<br>| INNODB_SYS_FOREIGN_COLS               |<br>| INNODB_CMPMEM                         |<br>| INNODB_BUFFER_POOL_STATS              |<br>| INNODB_SYS_COLUMNS                    |<br>| INNODB_SYS_FOREIGN                    |<br>| INNODB_SYS_TABLESTATS                 |<br>+—————————————+</p>\n<p>mysql&gt; desc table_constraints;（该表格中专门存储约束信息）<br>+——————–+————–+——+—–+———+——-+<br>| Field              | Type         | Null | Key | Default | Extra |<br>+——————–+————–+——+—–+———+——-+<br>| CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |<br>| CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |<br>| CONSTRAINT_NAME    | varchar(64)  | NO   |     |         |       |<br>| TABLE_SCHEMA       | varchar(64)  | NO   |     |         |       |<br>| TABLE_NAME         | varchar(64)  | NO   |     |         |       |<br>| CONSTRAINT_TYPE    | varchar(64)  | NO   |     |         |       |<br>+——————–+————–+——+—–+———+——-+<br>6 rows in set (0.00 sec)</p>\n<p>mysql&gt; select constraint_name from table_constraints where table_name=’t_user’;<br>+————————–+<br>| constraint_name          |<br>+————————–+<br>| t_user_email_name_unique |<br>+————————–+</p>\n<p>5、not null和unique可以联合使用吗？</p>\n<pre><code>- 可以联合使用\n- 被not null unique约束的字段，既不能为空，也不能重复\n- 例：\n</code></pre><p>drop table if exists t_user;<br>create table t_user(<br>    id int(10),<br>    name varchar(32) not null unique<br>);</p>\n<p>6、主键约束-primary key 简称PK<br>    6.1主键涉及到的术语：<br>        -主键约束</p>\n<pre><code>    - 主键字段\n    - 主键值\n6.2 以上的关系：\n    表中的某个字段添加主键约束之后，该字段称为主键字段，主键字段中出现的每个值都被称为主键值。\n\n6.3 给某个字段添加主键约束之后，该字段不能重复，也不能为空。效果和“not null unique&quot;约束相同，但本质不同，主键字段还会默认添加”索引-index“\n\n6.4 和张表应该有主键字段，若没有，表示这张表是无效的。\n”主键值“是当前行数据的唯一标识。”主键值“是当前行数据的身份证号。\n即使表中现行记录相关的数据是相同的，但是由于主键值不同，我们认为这两行是完全不同的数据。\n\n6.5  给一个字段添加主键约束，称为单一主键。\n单一主键：\n//列级约束(这种方式用的多)\n    drop table if exists t_user;\n    create table t_user(\n        id int(10) primary key,\n        name varchar(32)\n    );\n\n单一主键：\n//表级约束\n    drop table if exists t_user;\n    create table t_user(\n        id int(10) ,\n        name varchar(32)，\n        primary key(id)\n    );\n\n\n单一主键：\n//表级约束\n//起名\n    drop table if exists t_user;\n    create table t_user(\n        id int(10) ,\n        name varchar(32)，\n        constraint t_user_id_pk primary key(id)\n    );\n\n6.6 给多个字段添加一个主键约束，称为复合主键。\n复合主键\n//表级约束\ndrop table if exists t_user;\n    create table t_user(\n        id int(10) ,\n        name varchar(32)，\n        email varchar(128),\n        primary key(id，name)\n    );\n\n\n复合主键\n//表级约束\n//起名\ndrop table if exists t_user;\n    create table t_user(\n        id int(10) ,\n        name varchar(32)，\n        email varchar(128),\n        constraint t_user_id_pk primary key(id，name)\n    );\n\n6.7 无论是单一主键还是复合主键，一张表主键约束只能有一个。\n\n6.8 主键根据性质分类：\n    - 自然主键\n         * 主键值若是一个自然数，这自然数和当前表的业务没有任何关系，这种主键叫做自然主键。\n    - 业务主键\n        * 主键值若和当前表中业务紧密相关的，这种主键值称为业务主键，当前业务数据发生改变的时候，主键值通常会受到影响，所以业务主键使用较少，大部分都 是使用自然主键。\n\n6.9  在    MYSQL数据库管理系统中提供了一个自增的数字，专门用来自动生成主键值。\n主键值不需要用户维护，也不需要用户提供，自动生成。数字默认从1开始，以1递增\n1,2,3,4,5,6\ndrop table if exists t_user;\ncreate table t_user(\n    id int(10) primary key auto_increment,\n    name varchar(32)，\n);\n</code></pre><p>7、外键约束-foreign key 简称 FK</p>\n<pre><code>7.1 外键涉及到的术语：\n    -外键约束\n    - 外键字段\n    - 外键值\n\n7.2 以上的关系：\n    表中的某个字段添加外键约束之后，该字段称为外键字段，外键字段中出现的每个值都被称为外键值。\n\n7.3 外键分为单一外键、复合外键\n\n7.4 一张表中可以有多个外键字段\n\n7.5 分析场景：\n请设计数据库表用来存储学生和班级信息，给出两种解决方案：\n学生信息和班级信息之间的关系，一个班级对应多个学生，这是典型的一对多的关系。\n\n第一种 ：将学生信息和班级信息存储到一张表中\n学生信息表t_student\nsno        sname      classno     cname\n-----------------------------------------\n1           jack         100      一班\n2           zhan         100      一班\n3           duck         200      二班\n4           fork         200      二班\n5           zhen         300      三班\n6           luck         400      三班\n以上的设计缺点：数据冗余\n\n第二种 ：学生信息和班级信息分开存储，学生表+班级表\n学生表t_student\nsno(pk)      sname      classno(fk)\n--------------------------\n1           a           100\n2           b           100\n3           c           200\n4           d           200\n5           e              300\n6           f            300\n\n班级表t_class\ncno(pk)      cname\n--------------------\n100          一班       \n200          二班\n300          三班\n\n结论：为了保证t_student表中的classno字段中的    数据必须来自于t_class表中cno字段中的数据，有必要给t_student表中的classno字段添加外键约束，classno字段被称为外键约束，字段中的100 200 300称为外键值，classno这里是单一外键字段。\n\n注：外键值可以为NULL\n\n注：外键字段去引用一张表的某个字段的时候，被引用的字段必须具有uniuqe约束。\n\n注：有了外键引用之后，表分了父表和子表，以上父表是班级表，子表是学生表 \n创建时先创建父表，再创建子表。删除时先删除子表中的数据，再删除父表中的数据，插入时先插入父表中的数据，再插入子表中的数据。 \n\n-----------------------SQL文----------------------------------\n</code></pre><p>drop table if exists t_student;<br>drop table if exists t_class;<br>create table t_class(<br>    cno int(3) primary key,<br>    cname varchar(32) not null<br>);<br>create table t_student(<br>    sno int(3) primary key,<br>    sname varchar(32) not null,<br>    classno int(3),<br>    constraint t_student_classno_fk foreign key(classno) references t_class(cno)<br>);<br>insert into t_class(cno,cname) values(100,’一班’);<br>insert into t_class(cno,cname) values(200,’二班’);<br>insert into t_class(cno,cname) values(300,’三班’);<br>insert into t_student(sno,sname,classno) values(1,’a’,100);<br>insert into t_student(sno,sname,classno) values(2,’b’,100);<br>insert into t_student(sno,sname,classno) values(3,’c’,200);<br>insert into t_student(sno,sname,classno) values(4,’d’,200);<br>insert into t_student(sno,sname,classno) values(5,’e’,300);<br>insert into t_student(sno,sname,classno) values(6,’f’,300);<br>select <em> from t_class;<br>select </em> from t_student;</p>\n<p>重点：典型的一对多的设计是在多的一方加外键</p>\n<p>8、级联更新和级联删除</p>\n<pre><code>- 添加级联更新和删除时候，需要在外键约束后面添加\n\n- 在删除父表中数据的时候，级联删除子表中的数据    on delete cascade\n    - 删除外键约束\n        alter table t_student drop foreign key t_student_classno_fk;\n    - 添加外键约束\n        alter table t_student add constraint t_student_classno_fk foreign key(classno) references t_class(cno) on delete cascade;\n\n- 在更新父表中数据的时候，级联更新子表中的数据       on update cascade\n    - 删除外键约束\n        alter table t_student drop foreign key t_student_classno_fk;\n    - 添加外键约束\n        alter table t_student add constraint t_student_classno_fk foreign key(classno) references t_class(cno) on update cascade;\n\n- 以上的级联更新和级联删除，谨慎使用，因为级联操作会将数据改变或者删除\n</code></pre>"},{"title":"deepin下搭建基于github和hexo的个人博客","date":"2018-09-13T13:11:19.000Z","_content":"\n### 搭建步骤： \n１. 安装git\n\n\n\t\t$ sudo apt-get install git \n\n- 查看git版本\n\n\n\t\t$ git version \n<!--more-->\n\n２． 安装Node.js及npm \n\n- 可以直接命令安装,但是命令安装的不是最新版本。\n\n\n\t\t$ sudo apt-get install nodejs $ sudo apt-get install npm \n\n- 本博客采用第二种方法，首先官网下载最新版，然后解压。将node,npm命令设置全局命令：\n\n\n\t\t$ sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/bin/node /usr/local/bin/node \n\t\t$ sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/bin/npm /usr/local/bin/npm \n\n- 查看版本：\n\n\n\t\t$ node -v $ npm -v \n\n 3、 安装hexo\n\n\t$ npm install -g hexo-cli \n\t\n\t\n   安装路径/home/dudefu/Documents/node-v8.6.0-linux-x64/lib/node_modules/hexo-cli，此时输入命令hexo会提示“未找到命令”，此时要将hexo-cli/bin/文件夹下的hexo命令设置为全局：\n\n\t$ sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/lib/node_modules/hexo-cli/bin/\n\t $ hexo /usr/local/bin/hexo 再输入hexo命令可以正常显示。 创建一个空文件夹，此处名为hexo：\n\n\t$ mkdir hexo \n    $ cd hexo \n    $ hexo init . \n    $ npm install \n    $ npm install hexo-deployer-git \n    \n 到此，hexo安装完毕。浏览器输入本地，前面配置均正确的情况下，正常显示博客首页。\n\n","source":"_posts/deepin下搭建基于github和hexo的个人博客.md","raw":"---\ntitle: deepin下搭建基于github和hexo的个人博客\ndate: 2018-09-13 21:11:19\ntags:\n---\n\n### 搭建步骤： \n１. 安装git\n\n\n\t\t$ sudo apt-get install git \n\n- 查看git版本\n\n\n\t\t$ git version \n<!--more-->\n\n２． 安装Node.js及npm \n\n- 可以直接命令安装,但是命令安装的不是最新版本。\n\n\n\t\t$ sudo apt-get install nodejs $ sudo apt-get install npm \n\n- 本博客采用第二种方法，首先官网下载最新版，然后解压。将node,npm命令设置全局命令：\n\n\n\t\t$ sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/bin/node /usr/local/bin/node \n\t\t$ sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/bin/npm /usr/local/bin/npm \n\n- 查看版本：\n\n\n\t\t$ node -v $ npm -v \n\n 3、 安装hexo\n\n\t$ npm install -g hexo-cli \n\t\n\t\n   安装路径/home/dudefu/Documents/node-v8.6.0-linux-x64/lib/node_modules/hexo-cli，此时输入命令hexo会提示“未找到命令”，此时要将hexo-cli/bin/文件夹下的hexo命令设置为全局：\n\n\t$ sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/lib/node_modules/hexo-cli/bin/\n\t $ hexo /usr/local/bin/hexo 再输入hexo命令可以正常显示。 创建一个空文件夹，此处名为hexo：\n\n\t$ mkdir hexo \n    $ cd hexo \n    $ hexo init . \n    $ npm install \n    $ npm install hexo-deployer-git \n    \n 到此，hexo安装完毕。浏览器输入本地，前面配置均正确的情况下，正常显示博客首页。\n\n","slug":"deepin下搭建基于github和hexo的个人博客","published":1,"updated":"2018-09-13T16:07:30.144Z","_id":"cjm0r966k0008mlfijjsk90b2","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"搭建步骤：\"><a href=\"#搭建步骤：\" class=\"headerlink\" title=\"搭建步骤：\"></a>搭建步骤：</h3><p>１. 安装git</p>\n<pre><code>$ sudo apt-get install git \n</code></pre><ul>\n<li>查看git版本</li>\n</ul>\n<pre><code>$ git version \n</code></pre><a id=\"more\"></a>\n<p>２． 安装Node.js及npm </p>\n<ul>\n<li>可以直接命令安装,但是命令安装的不是最新版本。</li>\n</ul>\n<pre><code>$ sudo apt-get install nodejs $ sudo apt-get install npm \n</code></pre><ul>\n<li>本博客采用第二种方法，首先官网下载最新版，然后解压。将node,npm命令设置全局命令：</li>\n</ul>\n<pre><code>$ sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/bin/node /usr/local/bin/node \n$ sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/bin/npm /usr/local/bin/npm \n</code></pre><ul>\n<li>查看版本：</li>\n</ul>\n<pre><code>$ node -v $ npm -v \n</code></pre><p> 3、 安装hexo</p>\n<pre><code>$ npm install -g hexo-cli \n</code></pre><p>   安装路径/home/dudefu/Documents/node-v8.6.0-linux-x64/lib/node_modules/hexo-cli，此时输入命令hexo会提示“未找到命令”，此时要将hexo-cli/bin/文件夹下的hexo命令设置为全局：</p>\n<pre><code>$ sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/lib/node_modules/hexo-cli/bin/\n $ hexo /usr/local/bin/hexo 再输入hexo命令可以正常显示。 创建一个空文件夹，此处名为hexo：\n\n$ mkdir hexo \n$ cd hexo \n$ hexo init . \n$ npm install \n$ npm install hexo-deployer-git \n</code></pre><p> 到此，hexo安装完毕。浏览器输入本地，前面配置均正确的情况下，正常显示博客首页。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"搭建步骤：\"><a href=\"#搭建步骤：\" class=\"headerlink\" title=\"搭建步骤：\"></a>搭建步骤：</h3><p>１. 安装git</p>\n<pre><code>$ sudo apt-get install git \n</code></pre><ul>\n<li>查看git版本</li>\n</ul>\n<pre><code>$ git version \n</code></pre>","more":"<p>２． 安装Node.js及npm </p>\n<ul>\n<li>可以直接命令安装,但是命令安装的不是最新版本。</li>\n</ul>\n<pre><code>$ sudo apt-get install nodejs $ sudo apt-get install npm \n</code></pre><ul>\n<li>本博客采用第二种方法，首先官网下载最新版，然后解压。将node,npm命令设置全局命令：</li>\n</ul>\n<pre><code>$ sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/bin/node /usr/local/bin/node \n$ sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/bin/npm /usr/local/bin/npm \n</code></pre><ul>\n<li>查看版本：</li>\n</ul>\n<pre><code>$ node -v $ npm -v \n</code></pre><p> 3、 安装hexo</p>\n<pre><code>$ npm install -g hexo-cli \n</code></pre><p>   安装路径/home/dudefu/Documents/node-v8.6.0-linux-x64/lib/node_modules/hexo-cli，此时输入命令hexo会提示“未找到命令”，此时要将hexo-cli/bin/文件夹下的hexo命令设置为全局：</p>\n<pre><code>$ sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/lib/node_modules/hexo-cli/bin/\n $ hexo /usr/local/bin/hexo 再输入hexo命令可以正常显示。 创建一个空文件夹，此处名为hexo：\n\n$ mkdir hexo \n$ cd hexo \n$ hexo init . \n$ npm install \n$ npm install hexo-deployer-git \n</code></pre><p> 到此，hexo安装完毕。浏览器输入本地，前面配置均正确的情况下，正常显示博客首页。</p>"},{"title":"git从远程库同步到本地仓库","date":"2018-09-13T13:38:19.000Z","_content":"\n## 远程仓库发生改变，本地仓库没有改变\n- #### 首先，查看远程仓库 git remote -v\n\n\n\t\t1  $ git remote -v\n\t\t2   origin\tgit@github.com:{User}/Understanding_Unix-Linux_Programming.git (fetch)\n\t\t3   origin\tgit@github.com:{User}/Understanding_Unix-Linux_Programming.git (push)\n\n- #### 把远程库更新到本地 git fetch origin master\n<!--more-->\n\n\n\t\t1 $ git fetch origin master\n\t\t2 Warning: Permanently added the RSA host key for IP address '{IP address such as: 192.168.1.1 }' to the list of known hosts.\n\t\t3 From github.com:{User}/Understanding_Unix-Linux_Programmin\n\t    4 branch            master     -> FETCH_HEAD\n\n- #### 比较远程更新和本地版本库的差异 git log master.. origin/master\n\n\n\t\t1 $ git log master.. origin/master\n\t\t2 commit ce39f8b3eeee898a2a038444f897f2aef3673493\n\t\t3 Author: {User} <794870409@qq.com>\n\t\t4 Date:   Fri Feb 26 14:14:39 2016 +0800\n\t\t5\n\t    6 {The context origin added ... }\n\n- #### 合并远程库 git merge origin/master\n\n- 有差异\n\n\n\n\t\t1 $ git merge origin/master\n\t\t2 Updating eb32b20..ce39f8b\n\t\t3 Fast-forward\n\t    4  README.md | 2 +-\n\t\t5  1 file changed, 1 insertion(+), 1 deletion(-)\n\n\n\n- 无差异\n\n\n\t\t1 $ git merge origin/master\n\t\t2 Already up-to-date\n","source":"_posts/git从远程库同步到本地仓库.md","raw":"---\ntitle: git从远程库同步到本地仓库\ndate: 2018-09-13 21:38:19\ntags:\n---\n\n## 远程仓库发生改变，本地仓库没有改变\n- #### 首先，查看远程仓库 git remote -v\n\n\n\t\t1  $ git remote -v\n\t\t2   origin\tgit@github.com:{User}/Understanding_Unix-Linux_Programming.git (fetch)\n\t\t3   origin\tgit@github.com:{User}/Understanding_Unix-Linux_Programming.git (push)\n\n- #### 把远程库更新到本地 git fetch origin master\n<!--more-->\n\n\n\t\t1 $ git fetch origin master\n\t\t2 Warning: Permanently added the RSA host key for IP address '{IP address such as: 192.168.1.1 }' to the list of known hosts.\n\t\t3 From github.com:{User}/Understanding_Unix-Linux_Programmin\n\t    4 branch            master     -> FETCH_HEAD\n\n- #### 比较远程更新和本地版本库的差异 git log master.. origin/master\n\n\n\t\t1 $ git log master.. origin/master\n\t\t2 commit ce39f8b3eeee898a2a038444f897f2aef3673493\n\t\t3 Author: {User} <794870409@qq.com>\n\t\t4 Date:   Fri Feb 26 14:14:39 2016 +0800\n\t\t5\n\t    6 {The context origin added ... }\n\n- #### 合并远程库 git merge origin/master\n\n- 有差异\n\n\n\n\t\t1 $ git merge origin/master\n\t\t2 Updating eb32b20..ce39f8b\n\t\t3 Fast-forward\n\t    4  README.md | 2 +-\n\t\t5  1 file changed, 1 insertion(+), 1 deletion(-)\n\n\n\n- 无差异\n\n\n\t\t1 $ git merge origin/master\n\t\t2 Already up-to-date\n","slug":"git从远程库同步到本地仓库","published":1,"updated":"2018-09-13T16:09:00.456Z","_id":"cjm0r966m0009mlfiushfxfav","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"远程仓库发生改变，本地仓库没有改变\"><a href=\"#远程仓库发生改变，本地仓库没有改变\" class=\"headerlink\" title=\"远程仓库发生改变，本地仓库没有改变\"></a>远程仓库发生改变，本地仓库没有改变</h2><ul>\n<li><h4 id=\"首先，查看远程仓库-git-remote-v\"><a href=\"#首先，查看远程仓库-git-remote-v\" class=\"headerlink\" title=\"首先，查看远程仓库 git remote -v\"></a>首先，查看远程仓库 git remote -v</h4></li>\n</ul>\n<pre><code>1  $ git remote -v\n2   origin    git@github.com:{User}/Understanding_Unix-Linux_Programming.git (fetch)\n3   origin    git@github.com:{User}/Understanding_Unix-Linux_Programming.git (push)\n</code></pre><ul>\n<li><h4 id=\"把远程库更新到本地-git-fetch-origin-master\"><a href=\"#把远程库更新到本地-git-fetch-origin-master\" class=\"headerlink\" title=\"把远程库更新到本地 git fetch origin master\"></a>把远程库更新到本地 git fetch origin master</h4><a id=\"more\"></a>\n</li>\n</ul>\n<pre><code>1 $ git fetch origin master\n2 Warning: Permanently added the RSA host key for IP address &apos;{IP address such as: 192.168.1.1 }&apos; to the list of known hosts.\n3 From github.com:{User}/Understanding_Unix-Linux_Programmin\n4 branch            master     -&gt; FETCH_HEAD\n</code></pre><ul>\n<li><h4 id=\"比较远程更新和本地版本库的差异-git-log-master-origin-master\"><a href=\"#比较远程更新和本地版本库的差异-git-log-master-origin-master\" class=\"headerlink\" title=\"比较远程更新和本地版本库的差异 git log master.. origin/master\"></a>比较远程更新和本地版本库的差异 git log master.. origin/master</h4></li>\n</ul>\n<pre><code>1 $ git log master.. origin/master\n2 commit ce39f8b3eeee898a2a038444f897f2aef3673493\n3 Author: {User} &lt;794870409@qq.com&gt;\n4 Date:   Fri Feb 26 14:14:39 2016 +0800\n5\n6 {The context origin added ... }\n</code></pre><ul>\n<li><h4 id=\"合并远程库-git-merge-origin-master\"><a href=\"#合并远程库-git-merge-origin-master\" class=\"headerlink\" title=\"合并远程库 git merge origin/master\"></a>合并远程库 git merge origin/master</h4></li>\n<li><p>有差异</p>\n</li>\n</ul>\n<pre><code>1 $ git merge origin/master\n2 Updating eb32b20..ce39f8b\n3 Fast-forward\n4  README.md | 2 +-\n5  1 file changed, 1 insertion(+), 1 deletion(-)\n</code></pre><ul>\n<li>无差异</li>\n</ul>\n<pre><code>1 $ git merge origin/master\n2 Already up-to-date\n</code></pre>","site":{"data":{}},"excerpt":"<h2 id=\"远程仓库发生改变，本地仓库没有改变\"><a href=\"#远程仓库发生改变，本地仓库没有改变\" class=\"headerlink\" title=\"远程仓库发生改变，本地仓库没有改变\"></a>远程仓库发生改变，本地仓库没有改变</h2><ul>\n<li><h4 id=\"首先，查看远程仓库-git-remote-v\"><a href=\"#首先，查看远程仓库-git-remote-v\" class=\"headerlink\" title=\"首先，查看远程仓库 git remote -v\"></a>首先，查看远程仓库 git remote -v</h4></li>\n</ul>\n<pre><code>1  $ git remote -v\n2   origin    git@github.com:{User}/Understanding_Unix-Linux_Programming.git (fetch)\n3   origin    git@github.com:{User}/Understanding_Unix-Linux_Programming.git (push)\n</code></pre><ul>\n<li><h4 id=\"把远程库更新到本地-git-fetch-origin-master\"><a href=\"#把远程库更新到本地-git-fetch-origin-master\" class=\"headerlink\" title=\"把远程库更新到本地 git fetch origin master\"></a>把远程库更新到本地 git fetch origin master</h4>","more":"</li>\n</ul>\n<pre><code>1 $ git fetch origin master\n2 Warning: Permanently added the RSA host key for IP address &apos;{IP address such as: 192.168.1.1 }&apos; to the list of known hosts.\n3 From github.com:{User}/Understanding_Unix-Linux_Programmin\n4 branch            master     -&gt; FETCH_HEAD\n</code></pre><ul>\n<li><h4 id=\"比较远程更新和本地版本库的差异-git-log-master-origin-master\"><a href=\"#比较远程更新和本地版本库的差异-git-log-master-origin-master\" class=\"headerlink\" title=\"比较远程更新和本地版本库的差异 git log master.. origin/master\"></a>比较远程更新和本地版本库的差异 git log master.. origin/master</h4></li>\n</ul>\n<pre><code>1 $ git log master.. origin/master\n2 commit ce39f8b3eeee898a2a038444f897f2aef3673493\n3 Author: {User} &lt;794870409@qq.com&gt;\n4 Date:   Fri Feb 26 14:14:39 2016 +0800\n5\n6 {The context origin added ... }\n</code></pre><ul>\n<li><h4 id=\"合并远程库-git-merge-origin-master\"><a href=\"#合并远程库-git-merge-origin-master\" class=\"headerlink\" title=\"合并远程库 git merge origin/master\"></a>合并远程库 git merge origin/master</h4></li>\n<li><p>有差异</p>\n</li>\n</ul>\n<pre><code>1 $ git merge origin/master\n2 Updating eb32b20..ce39f8b\n3 Fast-forward\n4  README.md | 2 +-\n5  1 file changed, 1 insertion(+), 1 deletion(-)\n</code></pre><ul>\n<li>无差异</li>\n</ul>\n<pre><code>1 $ git merge origin/master\n2 Already up-to-date\n</code></pre>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-09-13T12:41:24.940Z","updated":"2018-09-13T12:41:24.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm0r966n000amlfiiw1fkvaw","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"使用hexo，如果换了电脑怎么更新博客","date":"2018-09-13T13:17:07.000Z","_content":"\n本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\n\n  \tgit clone -b hexo git@github.com:zhb514685388/zhb514685388.github.io.git拷贝仓库（默认分支为hexo）；\n\n在本地新拷贝的hb514685388.github.io文件夹下通过Git bash依次执行下列指令：\n\n\tnpm install hexo、\n\tnpm install、\n\tnpm install hexo-deployer-git\n    （记得，不需要hexo init这条指令）\n","source":"_posts/使用hexo，如果换了电脑怎么更新博客.md","raw":"---\ntitle: 使用hexo，如果换了电脑怎么更新博客\ndate: 2018-09-13 21:17:07\ntags:\n---\n\n本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\n\n  \tgit clone -b hexo git@github.com:zhb514685388/zhb514685388.github.io.git拷贝仓库（默认分支为hexo）；\n\n在本地新拷贝的hb514685388.github.io文件夹下通过Git bash依次执行下列指令：\n\n\tnpm install hexo、\n\tnpm install、\n\tnpm install hexo-deployer-git\n    （记得，不需要hexo init这条指令）\n","slug":"使用hexo，如果换了电脑怎么更新博客","published":1,"updated":"2018-09-13T15:54:30.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm0r966q000bmlfil3zad0cg","content":"<p>本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p>\n<pre><code>git clone -b hexo git@github.com:zhb514685388/zhb514685388.github.io.git拷贝仓库（默认分支为hexo）；\n</code></pre><p>在本地新拷贝的hb514685388.github.io文件夹下通过Git bash依次执行下列指令：</p>\n<pre><code>npm install hexo、\nnpm install、\nnpm install hexo-deployer-git\n（记得，不需要hexo init这条指令）\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p>\n<pre><code>git clone -b hexo git@github.com:zhb514685388/zhb514685388.github.io.git拷贝仓库（默认分支为hexo）；\n</code></pre><p>在本地新拷贝的hb514685388.github.io文件夹下通过Git bash依次执行下列指令：</p>\n<pre><code>npm install hexo、\nnpm install、\nnpm install hexo-deployer-git\n（记得，不需要hexo init这条指令）\n</code></pre>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}